/*
 * Juno - OpenVera (TM) to Jove Translator
 * Copyright (C) 2005 Newisys, Inc. or its licensors, as applicable.
 * VERA and OpenVera are trademarks or registered trademarks of Synopsys, Inc.
 *
 * Licensed under the Open Software License version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You should
 * have received a copy of the License along with this software; if not, you
 * may obtain a copy of the License at
 *
 * http://opensource.org/licenses/osl-2.0.php
 *
 * This software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */

package com.newisys.juno.runtime;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.newisys.dv.ClockSignal;
import com.newisys.dv.DV;
import com.newisys.dv.InOutSignal;
import com.newisys.dv.InputSignal;
import com.newisys.dv.Mailbox;
import com.newisys.dv.OutputSignal;
import com.newisys.dv.PortSignalWrapper;
import com.newisys.dv.Semaphore;
import com.newisys.dv.Signal;
import com.newisys.eventsim.Event;
import com.newisys.eventsim.SimulationThread;
import com.newisys.printf.VeraPrintfFormatter;
import com.newisys.random.LinearCongruentialFactory;
import com.newisys.random.PRNG;
import com.newisys.random.PRNGFactoryFactory;
import com.newisys.util.system.SystemUtil;
import com.newisys.util.text.TextUtil;
import com.newisys.verilog.EdgeSet;
import com.newisys.verilog.util.Bit;
import com.newisys.verilog.util.BitVector;
import com.newisys.verilog.util.BitVectorFormat;
import com.newisys.verilog.util.ValueConverter;

/**
 * Implementations of Vera's built-in functions for use by translated code.
 * 
 * @author Jon Nall
 * @author Trevor Robinson
 */
public final class Juno
{
    ////////////////////////////////////////////////////////////
    // Static data
    ////////////////////////////////////////////////////////////

    /**
     * Represents the system clock, "CLOCK". It must be initialized before
     * any classes generated by the translator are loaded.
     */
    public static ClockSignal systemClock;

    /**
     * Map of SimulationThread objects to the current JunoThreadContext for each
     * thread.
     */
    private static Map<SimulationThread, JunoThreadContext> threadContextMap;

    /**
     * Property set representing the plus-args.
     */
    private static Properties props;

    public static void initialize()
    {
        systemClock = DV.simulation.getDefaultClockSignal();

        threadContextMap = new HashMap<SimulationThread, JunoThreadContext>();
        props = new Properties();

        // load default properties from file
        final String defaultPropsFile = "jove.ini";
        try
        {
            FileInputStream input = new FileInputStream(defaultPropsFile);
            props.load(input);
        }
        catch (IOException e)
        {
            System.err.println("Unable to open default properties file '"
                + defaultPropsFile + "': " + e.getMessage());
        }

        // get properties from command line
        final Iterator<String> iter = DV.simulation.getArguments().iterator();
        while (iter.hasNext())
        {
            final String arg = iter.next();
            if (arg.startsWith("+"))
            {
                int equalsPos = arg.indexOf('=');
                if (equalsPos > 0)
                {
                    props.setProperty(arg.substring(1, equalsPos), arg
                        .substring(equalsPos + 1));
                }
            }
        }

        // get initial random seed from command line
        int seed = 1;
        if (!get_plus_arg(CHECK, "random_seed=").isZero())
        {
            seed = get_plus_arg(NUM, "random_seed=").intValue();
        }
        srandom(seed);
    }

    ////////////////////////////////////////////////////////////
    // Java array translation helpers
    ////////////////////////////////////////////////////////////

    /**
     * Initializes the given Object array with the given value, starting at the
     * given index and continuing to the end of the array.
     *
     * @param <T> the array element type
     * @param array the array to initialize
     * @param value the initial value
     * @param start the starting index
     * @return the given array
     */
    public static <T> T[] initArray(T[] array, T value, int start)
    {
        if (!array.getClass().getComponentType().isArray())
        {
            // single-dimensional array
            for (int i = start; i < array.length; ++i)
            {
                array[i] = value;
            }
        }
        else
        {
            // multi-dimensional array
            for (int i = start; i < array.length; ++i)
            {
                @SuppressWarnings("unchecked")
                T[] nestedArray = (T[]) array[i];
                initArray(nestedArray, value, 0);
            }
        }
        return array;
    }

    /**
     * Initializes the given Object array with values from the given factory,
     * starting at the given index and continuing to the end of the array.
     *
     * @param <T> the array element type
     * @param array the array to initialize
     * @param factory the factory providing initial values
     * @param start the starting index
     * @return the given array
     */
    public static <T> T[] initArray(
        T[] array,
        ValueFactory<T> factory,
        int start)
    {
        if (!array.getClass().getComponentType().isArray())
        {
            // single-dimensional array
            for (int i = start; i < array.length; ++i)
            {
                array[i] = factory.newInstance();
            }
        }
        else
        {
            // multi-dimensional array
            for (int i = start; i < array.length; ++i)
            {
                @SuppressWarnings("unchecked")
                T[] nestedArray = (T[]) array[i];
                initArray(nestedArray, factory, 0);
            }
        }
        return array;
    }

    /**
     * Copies the given source array into the given destination array, and
     * initializes any extra elements in the destination array with the given
     * value.
     *
     * @param <T> the array element type
     * @param dstArray the array to copy into
     * @param srcArray the array to copy from
     * @param initExtra value used to initialize the rest of the destination
     *            array, if the source array is shorter
     * @return the destination array
     */
    public static <T> T[] copyArray(T[] dstArray, T[] srcArray, T initExtra)
    {
        boolean dstArrayMultiDim = dstArray.getClass().getComponentType()
            .isArray();
        assert (srcArray.getClass().getComponentType().isArray() == dstArrayMultiDim);
        int copyLen = Math.min(srcArray.length, dstArray.length);
        if (!dstArrayMultiDim)
        {
            // single-dimensional array
            for (int i = 0; i < copyLen; ++i)
            {
                dstArray[i] = srcArray[i];
            }
        }
        else
        {
            // multi-dimensional array
            for (int i = 0; i < copyLen; ++i)
            {
                @SuppressWarnings("unchecked")
                T[] nestedDstArray = (T[]) dstArray[i];

                @SuppressWarnings("unchecked")
                T[] nestedSrcArray = (T[]) srcArray[i];
                copyArray(nestedDstArray, nestedSrcArray, initExtra);
            }
        }
        if (copyLen < dstArray.length)
        {
            initArray(dstArray, initExtra, copyLen);
        }
        return dstArray;
    }

    /**
     * Clones the elements in the given source array into the given destination
     * array, and initializes any extra elements in the destination array, using
     * the given value factory.
     *
     * @param <T> the array element type
     * @param dstArray the array to copy into
     * @param srcArray the array to copy from
     * @param factory the value factory used to copy and initialize values
     * @return the destination array
     */
    public static <T> T[] copyArray(
        T[] dstArray,
        T[] srcArray,
        ValueFactory<T> factory)
    {
        boolean dstArrayMultiDim = dstArray.getClass().getComponentType()
            .isArray();
        assert (srcArray.getClass().getComponentType().isArray() == dstArrayMultiDim);
        int copyLen = Math.min(srcArray.length, dstArray.length);
        if (!dstArrayMultiDim)
        {
            // single-dimensional array
            for (int i = 0; i < copyLen; ++i)
            {
                dstArray[i] = factory.copyInstance(srcArray[i]);
            }
        }
        else
        {
            // multi-dimensional array
            for (int i = 0; i < copyLen; ++i)
            {
                @SuppressWarnings("unchecked")
                T[] nestedDstArray = (T[]) dstArray[i];

                @SuppressWarnings("unchecked")
                T[] nestedSrcArray = (T[]) srcArray[i];
                copyArray(nestedDstArray, nestedSrcArray, factory);
            }
        }
        if (copyLen < dstArray.length)
        {
            initArray(dstArray, factory, copyLen);
        }
        return dstArray;
    }

    ////////////////////////////////////////////////////////////
    // cast_assign translation helpers
    ////////////////////////////////////////////////////////////

    public static void badCast()
    {
        throw new RuntimeException("Bad cast");
    }

    ////////////////////////////////////////////////////////////
    // Operator translation helpers
    ////////////////////////////////////////////////////////////

    public static boolean equals(Object o1, Object o2)
    {
        return o1 == o2 || (o1 != null && o1.equals(o2));
    }

    ////////////////////////////////////////////////////////////
    // Associative array utilities
    ////////////////////////////////////////////////////////////

    public static final int CHECK = 0;
    public static final int FIRST = 1;
    public static final int NEXT = 2;
    public static final int DELETE = 3;

    /**
     * assoc_index built-in function for dealing with entire arrays.
     * <P>
     * If op == CHECK, this method returns the number of elements in array.
     * <P>
     * If op == DELETE, this method deletes all elements in array.
     * <P>
     * @see #assoc_index(int, AssocArray, Object)
     * @see #assoc_index(int, AssocArray, Object[])
     * @param op Either {@link #CHECK}or {@link #DELETE}
     * @param array the array on which to perform the operation
     * @return the size of the array if op == CHECK or a 1 if op == DELETE
     */
    public static int assoc_index(int op, AssocArray< ? , ? > array)
    {
        if (op == CHECK)
        {
            return array.check();
        }
        else if (op == DELETE)
        {
            return array.delete();
        }
        else
        {
            throw new IllegalArgumentException(
                "assoc_index: op must be CHECK or DELETE");
        }
    }

    /**
     * assoc_index built-in function for dealing with array elements.
     * <P>
     * If op == CHECK, return whether or not array[index] is valid.
     * <P>
     * If op == DELETE, invalidate array[index] if it exists.
     * <P>
     * @see #assoc_index(int, AssocArray)
     * @see #assoc_index(int, AssocArray, Object[])
     * @param op Either {@link #CHECK}or {@link #DELETE}
     * @param array the array on which to perform the operation
     * @param index the index of array on which to perform op
     * @return if op == CHECK, return 0 if index in array is valid, 0 if it is
     *         not valid. if op == DELETE, return 1 if the element at index was
     *         removed from the array, and 0 if the element was not found in the
     *         array.
     * @throws IllegalArgumentException if index is null, or is a BitVector
     *         containing an X/Z value, or index is not either a BitVector,
     *         String or JunoString object
     */
    public static int assoc_index(int op, AssocArray array, Object index)
    {
        // if this assertion fires, we probably need another overloaded version
        // similar to Juno.assoc_index(int, AssocArray, int[]).
        assert (!index.getClass().isArray());

        if (op != CHECK && op != DELETE)
        {
            throw new IllegalArgumentException(
                "assoc_index: op must be CHECK or DELETE");
        }

        if (index == null)
        {
            throw new IllegalArgumentException(
                "assoc_index: index cannot be null");
        }

        if (array instanceof BitAssocArray)
        {
            BitAssocArray< ? > bitArray = (BitAssocArray) array;
            BitVector bitIndex = ValueConverter.toBitVector(index);
            if (bitIndex.containsXZ())
            {
                throw new IllegalArgumentException("assoc_index: index ("
                    + bitIndex + ") cannot contain X/Z");
            }
            return (op == DELETE) ? bitArray.delete(bitIndex) : bitArray
                .check(bitIndex);
        }
        else if (array instanceof StringAssocArray)
        {
            StringAssocArray< ? > strArray = (StringAssocArray) array;
            String strIndex;
            if (index instanceof String)
            {
                strIndex = (String) index;
            }
            else if (index instanceof JunoString)
            {
                strIndex = ((JunoString) index).toStringOrNull();
                if (strIndex == null)
                {
                    throw new IllegalArgumentException(
                        "assoc_index: string index cannot be null");
                }
            }
            else
            {
                throw new IllegalArgumentException(
                    "assoc_index: illegal index type for string array: "
                        + index.getClass().getName());
            }
            return (op == DELETE) ? strArray.delete(strIndex) : strArray
                .check(strIndex);
        }
        else
        {
            throw new IllegalArgumentException(
                "assoc_index: unknown array type: "
                    + array.getClass().getName());
        }
    }

    /**
     * See {@link #assoc_index(int, AssocArray, Object[])}. This method is
     * identical except the type of <code>index_ref</code> is
     * <code>int[]</code>.
     *
     * @param op Either {@link #FIRST}or {@link #NEXT}or {@link #CHECK} or
     *            {@link #DELETE}
     * @param array the array on which to perform the operation
     * @param index_ref an array holding a reference to the index of
     *      <code>array</code> on which to perform <code>op</code>
     * @return see {@link #assoc_index(int, AssocArray, Object[])}
     * @throws IllegalArgumentException if index_ref is null or contains more
     *      than 1 element
     */
    public static int assoc_index(int op, AssocArray array, int[] index_ref)
    {
        // perform manual boxing/unboxing operations and call the Object[]
        // version of assoc_index.
        if (index_ref == null || index_ref.length != 1)
        {
            throw new IllegalArgumentException(
                "assoc_index: index reference must be single-element array");
        }

        Integer[] new_index_ref = new Integer[1];
        new_index_ref[0] = index_ref[0];
        final int status = assoc_index(op, array, new_index_ref);
        index_ref[0] = new_index_ref[0];
        return status;
    }

    /**
     * assoc_index built-in function for dealing with array elements.
     * <P>
     * If op == FIRST, index_ref[0] is set to the first valid index of the
     * array. If a valid first element is found, a 1 is returned and
     * index_ref[0] is set to that element. If not, a 0 is returned and
     * index_ref[0] is left unchanged.
     * <P>
     * If op == NEXT, index_ref[0] is set to the next valid index of the array.
     * If a valid next element is found, a 1 is returned and index_ref[0] is set
     * to that element. If not, a 0 is returned and index_ref[0] is left
     * unchanged.
     * <P>
     * If op == CHECK, return whether or not array[index] exists. If it does, a
     * 1 is returned. If not, a 0 is returned.
     * <P>
     * If op == DELETE, invalidate array[index] if it exists. If it is
     * successful, a 1 is returned. If the element did not exist, a 0 is
     * returned.
     * <P>
     * @see #assoc_index(int, AssocArray)
     * @param op Either {@link #FIRST}or {@link #NEXT}or {@link #CHECK} or
     *      {@link #DELETE}
     * @param array the array on which to perform the operation
     * @param index_ref an array holding a reference to the index of
     *      <code>array</code> on which to perform op
     * @return see above
     * @throws IllegalArgumentException if index_ref is null or contains more
     *      than 1 element, or if index_ref[0] is a BitVector containing
     *      an X/Z value, or index_ref[0] is not either a BitVector,
     *      String or JunoString object
     */

    public static int assoc_index(int op, AssocArray array, Object[] index_ref)
    {
        if (index_ref == null || index_ref.length != 1)
        {
            throw new IllegalArgumentException(
                "assoc_index: index reference must be single-element array");
        }

        Object index = index_ref[0];
        if (op == CHECK || op == DELETE)
        {
            return assoc_index(op, array, index);
        }
        else if (op == FIRST)
        {
            if (array instanceof BitAssocArray)
            {
                BitAssocArray< ? > bitArray = (BitAssocArray) array;
                BitVector bitIndex = bitArray.first();
                if (bitIndex.containsXZ())
                {
                    index = null;
                }
                else if (index_ref instanceof BitVector[])
                {
                    index = bitIndex;
                }
                else
                {
                    assert (index_ref instanceof Integer[]);
                    index = IntegerOp.toInteger(bitIndex);
                }
            }
            else if (array instanceof StringAssocArray)
            {
                StringAssocArray< ? > strArray = (StringAssocArray) array;
                String strIndex = strArray.first();
                if (strIndex == null || index_ref instanceof String[])
                {
                    index = strIndex;
                }
                else
                {
                    assert (index_ref instanceof JunoString[]);
                    assert (index instanceof JunoString);
                    ((JunoString) index).assign(strIndex);
                }
            }
            else
            {
                throw new IllegalArgumentException(
                    "assoc_index: unknown array type: "
                        + array.getClass().getName());
            }
            if (index == null)
            {
                // leave index_ref unchanged if first() fails
                return 0;
            }
            index_ref[0] = index;
            return 1;
        }
        else if (op == NEXT)
        {
            if (index == null)
            {
                throw new IllegalArgumentException(
                    "assoc_index: index cannot be null");
            }

            if (array instanceof BitAssocArray)
            {
                BitAssocArray bitArray = (BitAssocArray) array;
                BitVector bitIndex = ValueConverter.toBitVector(index);
                if (bitIndex.containsXZ())
                {
                    throw new IllegalArgumentException("assoc_index: index ("
                        + bitIndex + ") cannot contain X/Z");
                }
                bitIndex = bitArray.next(bitIndex);
                if (bitIndex.containsXZ())
                {
                    index = null;
                }
                else if (index_ref instanceof BitVector[])
                {
                    index = bitIndex;
                }
                else
                {
                    assert (index_ref instanceof Integer[]);
                    index = IntegerOp.toInteger(bitIndex);
                }
            }
            else if (array instanceof StringAssocArray)
            {
                StringAssocArray< ? > strArray = (StringAssocArray) array;
                String strIndex;
                if (index instanceof String)
                {
                    strIndex = (String) index;
                }
                else if (index instanceof JunoString)
                {
                    strIndex = ((JunoString) index).toStringOrNull();
                    if (strIndex == null)
                    {
                        throw new IllegalArgumentException(
                            "assoc_index: string index cannot be null");
                    }
                }
                else
                {
                    throw new IllegalArgumentException(
                        "assoc_index: illegal index type for string array: "
                            + index.getClass().getName());
                }
                strIndex = strArray.next(strIndex);
                if (strIndex == null || index_ref instanceof String[])
                {
                    index = strIndex;
                }
                else
                {
                    assert (index_ref instanceof JunoString[]);
                    assert (index instanceof JunoString);
                    ((JunoString) index).assign(strIndex);
                }
            }
            else
            {
                throw new IllegalArgumentException(
                    "assoc_index: unknown array type: "
                        + array.getClass().getName());
            }
            if (index == null)
            {
                // leave index_ref unchanged if next() fails
                return 0;
            }
            index_ref[0] = index;
            return 1;
        }
        else
        {
            throw new IllegalArgumentException(
                "assoc_index: op must be CHECK, DELETE, FIRST, or NEXT");
        }
    }

    public static final int NUM = 1;
    public static final int STR = 2;
    public static final int HNUM = 3;

    /**
     * Returns a plusarg value as defined in jove.ini or on the command line.
     *
     * @param name A String containing the name of the property to be queried. A
     * good practice is end this String with '=' (e.g. "txns=").
     * @param defaultValue The String that should be returned if name is not
     * specified.
     * @return A String containing the user-specified value for the plusarg
     * described by name, or defaultValue if such a plusarg was not specified.
     */
    static String getProperty(String name, String defaultValue)
    {
        // Vera matches the leading substring, so:
        // get_plus_arg(HNUM, "foo") with +foobad=20
        // returns a bit vector with value 0xBAD (from fooBAD)
        // get_plus_arg(STR, "foo") with +foobar=20
        // returns a bit string of ASCII values for "bar=20"
        //
        // this is screwy and i'm not implementing it for now. sane
        // users should enforce their plusargs by suffixing them with "="
        if (!name.endsWith("="))
        {
            throw new RuntimeException(
                "Currently only plusargs ending in \"=\" are supported");
        }
        name = name.substring(0, name.length() - 1);

        return props.getProperty(name, defaultValue);
    }
    
    /**
     * Returns a clone of the Properties from jove.ini and command line.
     * @return a clone of the Properties.
     */
    static public Properties getProperties()
    {
        return (Properties) props.clone();
    }

    /**
     * Returns a plusarg value as defined in jove.ini or on the command line.
     *
     * @param op one of {@link #CHECK}, {@link #NUM}, {@link #STR}, or
     * {@link #HNUM} which determines how the value associated with a given
     * plusarg is interpreted.
     * @param name A String containing the name of the property to be queried. A
     * good practice is end this String with '=' (e.g. "txns=").
     * @return A BitVector containing the user-specified value for the plusarg
     * described by name interpreted as described by op. If name was not
     * specified by the user, a BitVector of value 32'h0 is returned.
     */
    public static BitVector get_plus_arg(int op, String name)
    {
        assert (op == CHECK || op == NUM || op == STR || op == HNUM);

        int result = 0;
        String s = getProperty(name, null);
        if (s != null)
        {
            switch (op)
            {
            case CHECK:
                result = 1;
                break;
            case NUM:
            case HNUM:
                // returns a 32 bit quantity
                // Vera reads the string until an invalid character is read
                // if a value >= 2^32 - 1 is given, 0xFFFFFFFF is returned
                s = s.replaceAll("_", "");
                int radix;
                if (op == NUM)
                {
                    s = s.replaceFirst("[^-0-9].*", "");
                    radix = 10;
                }
                else
                {
                    s = s.replaceFirst("[^0-9A-Fa-f].*", "");
                    radix = 16;
                }
                if (s.length() == 0)
                {
                    result = 0;
                }
                else if (op == HNUM && s.length() > 8 || op == NUM
                    && s.length() > 11)
                {
                    // 32 bit limits:
                    // 8 char limit for hex values
                    // 11 char for decimal (10 digits + minus sign)
                    result = ~0;
                }
                else
                {
                    long longResult = Long.parseLong(s, radix);
                    result = (longResult > Integer.MAX_VALUE) ? ~0
                        : (int) longResult;
                }
                break;
            case STR:
                // returns a "bit string" (Vera's term, not mine)
                // the bit vector returned will be the length of the string
                // time 8. with the bit strings containing the ASCII
                // representation
                if (s.startsWith("\"") && s.endsWith("\""))
                {
                    s = s.substring(1, s.length() - 1);
                }

                // reverse the bytes since charAt(0) will be in the uppermost 8
                // bits
                // of the bit vector
                byte[] sBytes = s.getBytes();
                byte[] reversedBytes = new byte[sBytes.length];
                for (int i = 0, j = sBytes.length - 1; i < sBytes.length; ++i, --j)
                {
                    reversedBytes[i] = sBytes[j];
                }
                BitVector v = new BitVector(reversedBytes);
                return v;
            default:
                assert (false);
            }
        }

        return new BitVector(32, result);
    }

    ////////////////////////////////////////////////////////////
    // Concurrency utilities
    ////////////////////////////////////////////////////////////

    public static final int SEMAPHORE = 0;
    public static final int REGION = 1;
    public static final int MAILBOX = 2;

    private static final String[] ALLOC_NAMES = { "SEMAPHORE", "REGION",
        "MAILBOX" };

    public static final int NO_WAIT = 0;
    public static final int WAIT = 1;
    public static final int COPY_NO_WAIT = 2;
    public static final int COPY_WAIT = 3;

    // internal variables
    private static final Map<Integer, Semaphore> semaphoreMap = new HashMap<Integer, Semaphore>();
    private static final Map<Integer, Mailbox<Object>> mailboxMap = new HashMap<Integer, Mailbox<Object>>();

    private static int alloc_internal(int type, int id, int count, int keyCount)
    {
        Map<Integer, ? > objectMap;
        switch (type)
        {
        case SEMAPHORE:
            objectMap = semaphoreMap;
            break;
        case REGION:
            throw new UnsupportedOperationException("Regions not implemented");
        case MAILBOX:
            objectMap = mailboxMap;
            break;
        default:
            throw new IllegalArgumentException(
                "Invalid object type for alloc(): " + type);
        }

        if (type != SEMAPHORE) assert (keyCount == 0);

        if (count < 1)
        {
            throw new IllegalArgumentException("Illegal count (" + count
                + ") for " + "alloc(" + ALLOC_NAMES[type] + ")");
        }

        // id is based on a lowest value of 1, not 0.
        --id;

        // If id is specified, use that range, creating mailboxes/regions
        // that don't exist or use an existing one if possible.
        // If id is not specified, return the lowest id that can hold
        // count object without conflicting with an existing object.

        int baseID = id;
        if (id == -1)
        {
            // calculate the lowest index that can hold count objects.
            baseID = -1;
            SortedSet<Integer> indices = new TreeSet<Integer>(objectMap
                .keySet());
            int allocIdx = 0;

            for (int curIdx : indices)
            {
                if (allocIdx + count <= curIdx)
                {
                    // found an entry with enough capacity
                    break;
                }
                else
                {
                    allocIdx = curIdx + 1;
                }
            }
            baseID = allocIdx;
        }

        for (int i = 0; i < count; ++i)
        {
            if (objectMap.containsKey(baseID + i))
            {
                // Vera doesn't overwrite existing objects
                continue;
            }

            switch (type)
            {
            case SEMAPHORE:
                final Semaphore semaphore = DV.simulation
                    .createSemaphore(keyCount);
                semaphoreMap.put(baseID + i, semaphore);
                break;
            case REGION:
                throw new UnsupportedOperationException(
                    "Regions not implemented");
            case MAILBOX:
                final Mailbox<Object> mailbox = DV.simulation.createMailbox();
                mailboxMap.put(baseID + i, mailbox);
                break;
            }
        }

        // baseID is based on a lowest value of 1, not 0.
        ++baseID;
        return baseID;
    }

    /**
     * alloc built-in function for allocating a REGION or a MAILBOX.
     * <P>
     * This method allocates either a region or a mailbox, based on type. If id
     * is 0, the next available id is used. This method attempts to allocate
     * count region/mailboxes.
     * <P>
     * If successful, the return value is the id of the first object. If id was
     * 0, this will be a non-zero value. If id was non-zero, this will be
     * identical to id. The objects are allocated contiguously so allocating N
     * objects will result in N valid contiguous values, starting at the id
     * returned.
     * <P>
     * When the allocation cannot be performed (e.g. there are no more
     * regions/mailboxes or count is greater than the maximum number of
     * regions/mailboxes available) a RuntimeException will occur.
     *
     * @param type one of either {@link #MAILBOX}or {@link #REGION}
     * @param id the base id to use. If 0, use the next available id.
     * @param count the number of objects to create.
     * @return the id of the first object created.
     * @throws IllegalArgumentException if count <= 0
     */
    public static int alloc(int type, int id, int count)
    {
        assert (type == REGION || type == MAILBOX);
        return alloc_internal(type, id, count, 0);
    }

    /**
     * alloc built-in function for allocating a REGION or a MAILBOX.
     * <P>
     * This method allocates a semaphore. If id is 0, the next available id is
     * used. This method attempts to allocate count semaphores.
     * <P>
     * If successful, the return value is the id of the first semaphore. If id
     * was 0, this will be a non-zero value. If id was non-zero, this will be
     * identical to id. The semaphore are allocated contiguously so allocating N
     * semaphores will result in N valid contiguous values, starting at the id
     * returned.
     * <P>
     * When the allocation cannot be performed (e.g. there are no more
     * semaphores or count is greater than the maximum number of semaphores
     * available) a RuntimeException will occur.
     *
     * @param type should be {@link #SEMAPHORE}
     * @param id the base id to use. If 0, use the next available id.
     * @param count the number of semaphores to create.
     * @param keyCount the number of keys initially available in each semaphore
     * @return the id of the first semaphore created.
     * @throws IllegalArgumentException if count <= 0
     */
    public static int alloc(int type, int id, int count, int keyCount)
    {
        assert (type == SEMAPHORE);
        return alloc_internal(type, id, count, keyCount);
    }

    /**
     * Release the specified number of keys to the specified semaphore.
     *
     * @param semaphore_id the semaphore to which the keys should be released
     * @param keyCount the number of keys to release
     */
    public static void semaphore_put(int semaphore_id, int keyCount)
    {
        assert (keyCount >= 0);
        --semaphore_id; // indexed from 0 internally

        Semaphore sem = semaphoreMap.get(semaphore_id);
        if (sem == null)
        {
            throw new RuntimeException("Uninitialized semaphore id ["
                + semaphore_id + "] for semaphore_put");
        }

        sem.release(keyCount);
    }

    /**
     * Acquire one or more keys from a given semaphore.
     * @param op One of {@link #WAIT} or {@link #NO_WAIT}. If op == WAIT, the
     * thread will block until keyCount keys can be acquired from the semaphore.
     * If op == NO_WAIT, the thread will not block and the return value can be
     * examined to check for success.
     * @param semaphore_id The Semaphore ID on which to operate.
     * @param keyCount The number of keys that should be acquired from the
     * semaphore.
     * @return 1 if keyCount keys were successfully acquired from the semaphore,
     * 0 otherwise.
     */
    public static int semaphore_get(int op, int semaphore_id, int keyCount)
    {
        // semaphore_get:
        // if op == WAIT, the return value is always 1, even if the
        // process has to wait some number of cycles to acquire the semaphore
        assert (op == WAIT || op == NO_WAIT);
        --semaphore_id; // indexed from 0 internally

        Semaphore sem = semaphoreMap.get(semaphore_id);
        if (sem == null)
        {
            throw new RuntimeException("Uninitialized semaphore id ["
                + semaphore_id + "] for semaphore_get");
        }

        boolean attemptSuccessful = false;
        if (op == NO_WAIT)
        {
            attemptSuccessful = sem.attempt(keyCount);
        }
        else
        {
            assert (op == WAIT);
            sem.acquire(keyCount);
            attemptSuccessful = true;
        }
        return (attemptSuccessful == true ? 1 : 0);
    }

    /**
     * NOTE: region_enter is currently unsupported.
     * @param op One of {@link #WAIT} or {@link #NO_WAIT}. If op == WAIT, the
     * thread will block until the region can be entered. If op == NO_WAIT, the
     * thread will not block and the return value can be examined to check for
     * success.
     * @param region_id The Region ID on which to operate.
     * @param values An array of values to acquire.
     * @return 1 if the region was successfully entered, 0 otherwise.
     */
    public static int region_enter(int op, int region_id, Object[] values)
    {
        // DEFERRED: region_enter
        assert (op == WAIT || op == NO_WAIT);
        --region_id; // indexed from 0 internally
        throw new UnsupportedOperationException("region_enter()");
    }

    /**
     * NOTE: region_exit is currently unsupported.
     * @param region_id The Region ID on which to operate.
     * @param values An array of values to release.
     */
    public static void region_exit(int region_id, Object[] values)
    {
        // DEFERRED: region_exit
        --region_id; // indexed from 0 internally
        throw new UnsupportedOperationException("region_enter()");
    }

    /**
     * Put an object into a given mailbox.
     * @param mailbox_id The Mailbox ID in which to put the object.
     * @param data The object to put into the mailbox.
     */
    public static void mailbox_put(int mailbox_id, Object data)
    {
        --mailbox_id; // indexed from 0 internally

        Mailbox<Object> mbox = mailboxMap.get(mailbox_id);
        if (mbox == null)
        {
            throw new RuntimeException("Uninitialized mailbox id ["
                + mailbox_id + "] for mailbox_put");
        }

        mbox.put(data);
    }

    /**
     * Returns the size of the given mailbox.
     * <P>
     * This is equivalent to calling mailbox_get(op, mailbox_id, null, 1);
     *
     * @param op One of {@link #WAIT}, {@link #NO_WAIT} {@link #COPY_WAIT}, or
     * {@link #COPY_NO_WAIT}. If op is WAIT or COPY_WAIT and the mailbox is
     * empty, the thread will block until the mailbox is non-empty. At that time
     * the number of elements in the mailbox is returned. If NO_WAIT or COPY_NO_WAIT
     * is specified, the number of elements in the mailbox is returned and the
     * thread will not block.
     * @param mailbox_id The Mailbox ID on which to operate.
     * @return the size of the given mailbox.
     */
    public static int mailbox_get(int op, int mailbox_id)
    {
        return mailbox_get(op, mailbox_id, null, 1);
    }

    /**
     * Retrieve an object from a given mailbox.
     * <P>
     * This is equivalent to calling mailbox_get(op, mailbox_id, data_ref, 1);
     *
     * @param op One of {@link #WAIT}, {@link #NO_WAIT} {@link #COPY_WAIT}, or
     * {@link #COPY_NO_WAIT}. If op is WAIT or COPY_WAIT, the thread will block
     * until data is available in the mailbox. Otherwise, the thread will not
     * block and the return value can be examined to check for success. If op
     * is COPY_WAIT or COPY_NO_WAIT and there is data in the mailbox, the data
     * will be copied to data_ref[0], but will not be removed from the mailbox.
     * The next request will get the same object. However, op == WAIT or NO_WAIT,
     * the data will be removed from the mailbox.
     * @param mailbox_id The Mailbox ID on which to operate.
     * @param data_ref An array into which the returned object will be placed. If
     * this value is null, op is ignored and the current size of the mailbox is
     * returned.
     * @return Returns the number of entries in the mailbox, or -1 if there is
     * a type mismatch.
     */
    public static int mailbox_get(int op, int mailbox_id, Object[] data_ref)
    {
        return mailbox_get(op, mailbox_id, data_ref, 1);
    }

    /**
     * Retrieve an object from a given mailbox.
     * <P>
     * @param op One of {@link #WAIT}, {@link #NO_WAIT} {@link #COPY_WAIT}, or
     * {@link #COPY_NO_WAIT}. If op is WAIT or COPY_WAIT, the thread will block
     * until data is available in the mailbox. Otherwise, the thread will not
     * block and the return value can be examined to check for success. If op
     * is COPY_WAIT or COPY_NO_WAIT and there is data in the mailbox, the data
     * will be copied to data_ref[0], but will not be removed from the mailbox.
     * The next request will get the same object. However, op == WAIT or NO_WAIT,
     * the data will be removed from the mailbox.
     * @param mailbox_id The Mailbox ID on which to operate.
     * @param data_ref An array into which the returned object will be placed. If
     * this value is null, the current size of the mailbox is returned. Note
     * that in the case of data_ref being null, if op is WAIT or COPY_WAIT and
     * the mailbox is empty, the thread will block.
     * @param check If set to 1 and the type of object in the mailbox is
     * incompatible with the type of object in data_ref[0], a -1 is returned and
     * the data is left in the mailbox. If such a type mismatch occurs and check
     * is 0, an exception will be thrown.
     * @return Returns the number of entries in the mailbox, or -1 if there is
     * a type mismatch and check is set to 1.
     */
    public static int mailbox_get(
        int op,
        int mailbox_id,
        Object[] data_ref,
        int check)
    {
        assert (op == WAIT || op == NO_WAIT || op == COPY_WAIT || op == COPY_NO_WAIT);

        // if this assert fails, i didn't understand the purpose of the []
        assert (data_ref == null || data_ref.length == 1);

        --mailbox_id; // indexed from 0 internally

        Mailbox<Object> mbox = mailboxMap.get(mailbox_id);
        if (mbox == null)
        {
            throw new RuntimeException("Uninitialized mailbox id ["
                + mailbox_id + "] for mailbox_put");
        }

        boolean wait = (op == WAIT || op == COPY_WAIT);

        // don't dequeue in case there is a type mismatch.
        Object obj = (wait) ? mbox.peekWait() : mbox.peekNoWait();
        int mboxSize = mbox.size();

        if (data_ref == null)
        {
            // return number of elements
            return mboxSize;
        }
        else if (mboxSize == 0 && (op == NO_WAIT || op == COPY_NO_WAIT))
        {
            // no elements in the mailbox and *NO_WAIT
            // VUM says to return zero here.
            return 0;
        }

        boolean typeMismatch = false;
        Class srcClass = (obj == null ? null : obj.getClass());
        Class destClass = data_ref.getClass().getComponentType();
        Object objToAssign = null;

        if (destClass != Object.class)
        {
            // check for assignability
            boolean srcIsNull = (obj == null);
            boolean srcIsString = (obj instanceof String || obj instanceof JunoString);
            boolean srcIsJunoObject = (obj instanceof JunoObject);
            boolean srcIsJunoEnum = (obj instanceof JunoEnum);
            boolean srcIsNumeric = (obj instanceof Integer
                || obj instanceof BitVector || obj instanceof Bit);
            boolean destIsNull = (data_ref == null || data_ref[0] == null);
            boolean destIsString = (destClass == String.class || destClass == JunoString.class);
            boolean destIsJunoObject = (JunoObject.class
                .isAssignableFrom(destClass));
            boolean destIsJunoEnum = (JunoEnum.class
                .isAssignableFrom(destClass));
            boolean destIsNumeric = (destClass == Integer.class
                || destClass == BitVector.class || destClass == Bit.class);
            // Conversions
            // * BitVector/Integer/Bit -> BitVector/Integer/Bit
            //   The destination is assigned as much of the BitVector as it can
            //       contain, based on its width, and any extra width in the
            //       destination is zero-padded
            // * BitVector/Integer/Bit -> String
            //   An exception is thrown
            // * BitVector/Integer/Bit -> Enum
            //   If an enumeration in the destination enum class has the
            //       numeric value of this BitVector/Integer/Bit, an assignment
            //       is made. If the BitVector containsXZ() the undefined enum of
            //       that class is returned. Otherwise there is a type mismatch.
            // * BitVector/Integer/Bit -> null, void, <no_param> do not compile.
            //   Throw a RuntimeException
            //
            // * String -> BitVector/Integer/Bit
            //   The String's ASCII representation is effectively put in a
            //       BitVector of size (String.length() * 8) bits and the
            //       conversion to BitVector/Integer/Bit is as for BitVectors
            //       above.
            // * String -> String
            //   The destination String is set to the source String
            // * String -> Enum
            //   This is a type mismatch.
            //
            // * null/void -> BitVector/Integer/Bit
            //   An exception is thrown
            // * null/void -> String
            //   The destination String is set to null
            // * null/void -> Enum
            //   This is a type mismatch
            //
            // * Object -> BitVector/Integer/String/Bit
            //   An exception is thrown
            // * Object -> Object
            //   If Destination object "is a" type of the source object, it
            //      succeeds
            //   Else an exception is thrown
            // * Object -> Enum
            //   This is a type mismatch
            //
            // * Enum -> BitVector/Integer/Bit
            //   The integer value associated with the enumeration is assigned
            //       to the dest, truncated, or zero-extended as appropriate. If
            //       the src is the undefined enumeration, the destination is
            //       filled with X values.
            //
            // * Enum -> String
            //   This is a type mismatch.
            //
            // * Enum -> Object
            //   This is a type mismatch.
            //
            // * Enum -> Enum
            //   Succeeds if the enumeration contains elements that have the
            //       same value. If the src is an undefined enumeration, then the
            //       assignment succeeds and the dest is the undefined enumeration.

            assert (srcIsNumeric || srcIsString || srcIsJunoObject
                || srcIsJunoEnum || obj == null);
            assert (destIsNumeric || destIsString || destIsJunoObject || destIsJunoEnum);

            if (srcIsNull)
            {
                // only strings and objects can be assigned null
                if (!(destIsString || destIsJunoObject))
                {
                    typeMismatch = true;
                }
                else
                {
                    objToAssign = obj;
                }
            }
            else if (srcIsString)
            {
                if (destIsNumeric)
                {
                    String s = null;
                    if (obj instanceof String)
                    {
                        s = (String) obj;
                    }
                    else
                    {
                        s = ((JunoString) obj).toStringOrNull();
                        if (s == null)
                        {
                            typeMismatch = true;
                        }
                    }

                    // reverse the bytes
                    byte[] sBytes = s.getBytes();
                    byte[] reversedBytes = new byte[sBytes.length];
                    for (int i = 0, j = sBytes.length - 1; i < sBytes.length - 1; ++i, --j)
                    {
                        reversedBytes[i] = sBytes[j];
                    }
                    BitVector vect = new BitVector(reversedBytes);
                    if (destClass == Integer.class)
                    {
                        objToAssign = IntegerOp.toInteger(vect);
                    }
                    else if (destClass == Bit.class)
                    {
                        objToAssign = BitOp.toBit(vect);
                    }
                    else if (destClass == BitVector.class)
                    {
                        assert (!destIsNull);
                        int length = ((BitVector) data_ref[0]).length();
                        objToAssign = vect.setLength(length);
                    }
                    else
                    {
                        assert (false);
                    }

                }
                else if (destIsString)
                {
                    if (obj.getClass() == data_ref[0].getClass())
                    {
                        objToAssign = obj;
                    }
                    else
                    {
                        // either String->JunoString or JunoString->String
                        if (obj instanceof String)
                        {
                            objToAssign = new JunoString((String) obj);
                        }
                        else
                        {
                            objToAssign = ((JunoString) obj).toString();
                        }
                    }
                }
                else
                {
                    // objects and enums can't be assigned from strings
                    typeMismatch = true;
                }
            }
            else if (srcIsNumeric)
            {
                if (destIsString || destIsJunoObject)
                {
                    typeMismatch = true;
                }
                else if (destIsJunoEnum)
                {
                    // if there is an enumeration in the class with the
                    // given value, assign that. else if this src contains
                    // X/Z values, use the undefined enum for that class
                    JunoEnum< ? > e = (JunoEnum) data_ref[0];
                    assert (e != null);

                    assert (srcClass == BitVector.class
                        || srcClass == Bit.class || srcClass == Integer.class);
                    Integer value = IntegerOp.toInteger(obj);

                    // get the value for this object, and use the default value
                    // if no enumeration element exists with the value given
                    final JunoEnum< ? > enumToAssign = e.getForValue(value,
                        true);
                    objToAssign = enumToAssign;

                    // if value was not X/Z and we didn't find a valid enumeration,
                    // that's a type mismatch
                    if (value != null && !enumToAssign.isDefined())
                    {
                        typeMismatch = true;
                    }
                }
                else
                {
                    if (srcClass == destClass)
                    {
                        if (srcClass == BitVector.class)
                        {
                            // need to keep length of dest unchanged.
                            objToAssign = ((BitVector) data_ref[0])
                                .assign((BitVector) obj);
                        }
                        else
                        {
                            objToAssign = obj;
                        }
                    }
                    else if (destClass == BitVector.class)
                    {
                        assert (srcClass == Bit.class || srcClass == Integer.class);
                        objToAssign = BitVectorOp.toBitVector(obj);
                    }
                    else if (destClass == Bit.class)
                    {
                        assert (srcClass == BitVector.class || srcClass == Integer.class);
                        objToAssign = BitOp.toBit(obj);
                    }
                    else if (destClass == Integer.class)
                    {
                        assert (srcClass == Bit.class || srcClass == BitVector.class);
                        objToAssign = IntegerOp.toInteger(obj);
                    }
                    else
                    {
                        assert (false);
                    }

                }
            }
            else if (srcIsJunoObject)
            {
                if (destIsJunoObject)
                {
                    objToAssign = obj;
                }
                else
                {
                    typeMismatch = true;
                }
            }
            else if (srcIsJunoEnum)
            {
                JunoEnum< ? > e = (JunoEnum) obj;
                Integer enumVal = e.toInteger();
                if (destIsNumeric)
                {
                    if (destClass == BitVector.class)
                    {
                        objToAssign = IntegerOp.toBitVector(enumVal, 32);
                    }
                    else if (destClass == Bit.class)
                    {
                        objToAssign = BitOp.toBit(enumVal);
                    }
                    else
                    {
                        assert (destClass == Integer.class);
                        objToAssign = enumVal;
                    }
                }
                else if (destIsJunoEnum)
                {
                    if (srcClass == destClass)
                    {
                        objToAssign = obj;
                    }
                    else
                    {
                        // check if destClass has an element corresponding to
                        // the integer value of obj. if so, use it. otherwise
                        // it's a type mismatch
                        try
                        {
                            JunoEnum< ? > destEnum = (JunoEnum) data_ref[0];
                            assert (destEnum != null);
                            objToAssign = destEnum.getForValue(enumVal, false);
                        }
                        catch (IllegalArgumentException excp)
                        {
                            typeMismatch = true;
                        }
                    }
                }
                else
                {
                    typeMismatch = true;
                }
            }
        }
        else
        {
            objToAssign = obj;
        }

        if (typeMismatch)
        {
            if (check == 1)
            {
                return -1;
            }
            throw new IllegalArgumentException(
                "mailbox_get: data type mismatch " + "(dest=" + destClass
                    + ", src=" + (obj == null ? null : srcClass) + ")");
        }

        if (op == NO_WAIT || op == WAIT)
        {
            // pop the mailbox if this wasn't just a COPY
            obj = mbox.getNoWait();
        }

        if (data_ref != null)
        {
            // if we get here without throwing an exception, do the assignment
            data_ref[0] = objToAssign;
        }
        return mboxSize;
    }

    public static final int OFF = 0;
    public static final int ON = 1;
    public static final int ONE_SHOT = 2;
    public static final int ONE_BLAST = 3;
    public static final int HAND_SHAKE = 4;

    /**
     * Triggers one or more JunoEvents in ONE_SHOT mode.
     *
     * @param events An array of JunoEvent objects that should be triggered.
     */
    public static void trigger(JunoEvent... events)
    {
        trigger(ONE_SHOT, events);
    }

    /**
     * Triggers one or more JunoEvents.
     *
     * @param op One of {@link #OFF}, {@link #ON}, {@link #ONE_SHOT},
     * {@link #ONE_BLAST}, and {@link #HAND_SHAKE}.
     * @param events An array of JunoEvent objects that should be triggered.
     */
    public static void trigger(int op, JunoEvent... events)
    {
        assert (op == OFF || op == ON || op == ONE_SHOT || op == ONE_BLAST || op == HAND_SHAKE);
        for (final JunoEvent e : events)
        {
            if (e == null) continue;
            switch (op)
            {
            case OFF:
                e.setOn(false);
                break;
            case ON:
                e.setOn(true);
                DV.simulation.notifyOf(e);
                break;
            case ONE_SHOT:
                DV.simulation.notifyOf(e);
                break;
            case ONE_BLAST:
                e.setOnDuringTime(DV.simulation.getSimTime());
                DV.simulation.notifyOf(e);
                break;
            case HAND_SHAKE:
                e.giveHandshake();
                DV.simulation.notifyOf(e);
                break;
            default:
                throw new UnsupportedOperationException("trigger(" + op + ")");
            }
        }
    }

    // DEFERRED: use switch's wherever possible as opposed to if/else.

    public static final int ALL = 1;
    public static final int ANY = 2;
    public static final int ORDER = 3;

    /**
     * Wait on a given set of JunoEvents to occur.<P>
     * Description of operation for various values of op:
     * <ul>
     * <li>CHECK - Check each JunoEvent in events. If any JunoEvent is OFF, return
     * 0, else return 1.
     * <li>ALL - Block until each JunoEvent in events has been triggered.
     * <li>ANY - Block until any JunoEvent in events has been triggered.
     * <li>ORDER - Block until each JunoEvent in events has been triggered in
     * the order they appear in the events array.
     * </ul>
     * <P>
     * TBD: under which circumstances do events which have occured before the
     * sync call satisfy the sync?
     *
     * @param op One of {@link #CHECK}, {@link #ALL}, {@link #ANY}, or {@link #ORDER}.
     * @param events An array of JunoEvents on which to sync.
     * @return if op == CHECK and any of the JunoEvents in events are OFF, a 0
     * is returned, else a 1 is returned.
     */
    public static int sync(int op, JunoEvent... events)
    {
        int result = 1;
        assert (op == CHECK || op == ALL || op == ANY || op == ORDER);
        if (op == CHECK)
        {
            for (final JunoEvent e : events)
            {
                if (e != null && !isEventOn(e, false))
                {
                    result = 0;
                    break;
                }
            }
        }
        else
        {
            final List<JunoEvent> waitEvents = new LinkedList<JunoEvent>();
            for (final JunoEvent e : events)
            {
                if (isEventOn(e, true))
                {
                    if (op == ANY)
                    {
                        waitEvents.clear();
                        break;
                    }
                }
                else if (e != null)
                {
                    waitEvents.add(e);
                }
            }
            if (!waitEvents.isEmpty())
            {
                if (op == ALL)
                {
                    DV.simulation.waitForAll(waitEvents);
                }
                else if (op == ANY)
                {
                    DV.simulation.waitForAny(waitEvents);
                }
                else
                {
                    // DEFERRED: sync: ORDER
                    throw new UnsupportedOperationException("sync(" + op + ")");
                }

                // if we had to block, waiting on the trigger, we didn't decrement
                // the handshakeCount in the isEventOn(e, true) call above. in this
                // case, do that manually to avoid multiple sync's triggering
                // from a single trigger(HAND_SHAKE)
                // TODO: refactor sync to consolidate handshake bookkeeping
                for (JunoEvent e : waitEvents)
                {
                    e.checkHandshake(true);
                }
            }
        }
        return result;
    }

    private static boolean isEventOn(Event e, boolean acquire)
    {
        if (e instanceof JunoEvent)
        {
            JunoEvent dvEvent = (JunoEvent) e;
            // consume handshakes before checking for other cases
            return dvEvent.checkHandshake(acquire) || dvEvent.isOn()
                || dvEvent.getOnDuringTime() == DV.simulation.getSimTime();
        }
        return false;
    }

    ////////////////////////////////////////////////////////////
    // Threading utilities
    ////////////////////////////////////////////////////////////

    /**
     * Enter a new thread context. This helps manage which threads should be
     * waited on during a wait_child() call.
     */
    public static void enter_context()
    {
        // get the current thread context, if any
        SimulationThread t = DV.simulation.currentThread();
        assert (t != null);
        JunoThreadContext pc = threadContextMap.get(t);

        // create a new thread context and map it as current
        JunoThreadContext c = new JunoThreadContext(pc);
        threadContextMap.put(t, c);
    }

    /**
     * Leave a thread context. This helps manage which threads should be
     * waited on during a wait_child() call.
     */
    public static void leave_context()
    {
        // get the current thread context
        SimulationThread t = DV.simulation.currentThread();
        assert (t != null);
        JunoThreadContext c = threadContextMap.get(t);
        assert (c != null);

        // map the parent thread context as current
        JunoThreadContext pc = c.getParentContext();
        threadContextMap.put(t, pc);
    }

    /**
     * Fork a new thread of execution.
     *
     * @param r the Runnable that will be executed in the new Thread.
     * @return a new SimulationThread which will run Runnable r.
     */
    public static SimulationThread fork(Runnable r)
    {
        return fork(null, r);
    }

    /**
     * Fork a new thread of execution.
     *
     * @param name a String identifier for the Thread
     * @param r the Runnable that will be executed in the new Thread.
     * @return a new SimulationThread which will run Runnable r.
     */
    public static SimulationThread fork(String name, Runnable r)
    {
        SimulationThread t = DV.simulation.fork(name, r);

        // add the thread to any contexts of the parent thread
        SimulationThread pt = DV.simulation.currentThread();
        assert (pt != null);
        JunoThreadContext pc = threadContextMap.get(pt);
        while (pc != null)
        {
            pc.addForkedThread(t);
            pc = pc.getParentContext();
        }

        return t;
    }

    /**
     * Block until all threads marked as children of the current thread have
     * exited.
     */
    public static void wait_child()
    {
        // get the current thread context, if any
        SimulationThread t = DV.simulation.currentThread();
        assert (t != null);
        JunoThreadContext c = threadContextMap.get(t);
        if (c != null)
        {
            // join all threads forked from the current context
            // (or a descendent context)
            List<SimulationThread> tl = c.getForkedThreads();
            SimulationThread[] ta = new SimulationThread[tl.size()];
            tl.toArray(ta);
            DV.simulation.joinAll(ta);
        }
    }

    ////////////////////////////////////////////////////////////
    // Formatting utilities
    ////////////////////////////////////////////////////////////

    public static void dumpStack(OutputStream oStream)
    {
        assert (oStream == System.err);
        Thread.dumpStack();
    }

    /**
     * psprintf built-in function.
     * <P>
     * This method is akin to C's printf() with a few differences:
     * <ul>
     * non-C format specs
     * <ul>
     * <li>%b binary
     * <li>%p prints name of the main program
     * <li>%m prints hierarchical trace, from main() to context of psprintf
     * <li>%v prints instance path of the Vera shell
     * <li>%_ prints path separator for the current simulator
     * </ul>
     * <P>
     * Conversion notes: <br>
     * enumeration literals are printed as numeric values. enumeration variables
     * are printed as (ENUM_VAR:XXXXXXXX) as described below
     * <P>
     * <ul>
     * <li>Conversions to binary (%b)
     * <ul>
     * <li>x/z values are printed in lowercase
     * <li>prints ASCII representation of strings in binary with
     * string.charAt(0) residing in the MSB of the bit vector. each char has its
     * bits reversed. Thus the string "AF" 0x41, 0x46 is represented as:
     * 1000_0010_0110_0010 (0x82, 0x62) in string
     * <li>prints enumerations as "(ENUM_VAR:XXXXXXXX)", with X being 0-f
     * <li>prints null or void as "(NULL)"
     * </ul>
     * <li>Conversions to character (%c)
     * <ul>
     * <li>prints character representation of lowest byte of int/BitVector
     * <li>X/Z values print empty strings
     * <li>prints first character of a string
     * <li>prints empty string for enumerations
     * <li>prints null or void as "(NULL)"
     * </ul>
     * <li>Conversions to signed decimal (%d, %i)
     * <ul>
     * <li>prints Integer as a signed value
     * <li>prints BitVector as an unsigned value
     * <li>prints quantities with X/Z as "?"
     * <li>prints enumerations as "(ENUM_VAR:XXXXXXXXXX)", with X being 0-9
     * <li>for strings, each character is converted to a decimal value and
     * these are concatenated together. this is just silly.
     * <li>prints null or void as "(NULL)"
     * </ul>
     * <li>Conversions to hexadecimal (%h, %x)
     * <ul>
     * <li>X/Z values are printed in uppercase
     * <li>hex digits are printed in lowercase
     * <li>prints strings as empty string
     * <li>prints enumerations as "(ENUM_VAR:XXXXXXXX)", with X being 0-f
     * <li>prints null or void as "(NULL)"
     * </ul>
     * <li>Conversions to stack trace (%m)
     * <ul>
     * <li>format width specifies how many stack frames prior to printfcontext
     * to omit. for instance A()->B()->C()->printf("%1m") will print a stack
     * trace of A()->B()
     * </ul>
     * <li>Conversions to octal (%o)
     * <ul>
     * <li>all Z's in a 3-bit quantity prints "Z"
     * <li>all X's in a 3-bit quantity prints "X"
     * <li>any 0/1/X/Z combination in a 3-bit quantity prints "?"
     * <li>for strings, each character is converted to an octal value and these
     * are concatenated together
     * <li>with no width specifier, 12 octal digits are printed
     * <li>prints null or void as "(NULL)"
     * </ul>
     * <li>Conversions to program name (%p)
     * <ul>
     * <li>TODO: need to document printf %p specifier
     * </ul>
     * <li>Conversions to string (%s)
     * <ul>
     * <li>prints integers as 4 characters -- 1 per byte
     * <li>quantities with X/Z values print empty strings
     * <li>prints integers/bit vectors/bits as their ASCII representation, as
     * though they were a string in memory (for instance, 16'4B4A is printed as
     * "KJ"). vectors that are not a multiple of 4 bits are zero-padded
     * <li>prints enumerations as their "string name" (e.g. "red")
     * <li>prints null or void as "(NULL)"
     * </ul>
     * <li>Conversions to unsigned decimal (%u)
     * <ul>
     * <li>prints 32 bit values as an unsigned quantities
     * <li>otherwise behaves as (%d, %i)
     * </ul>
     * </ul>
     *
     * Note that the sequence "\\" is not unescaped by this function.
     *
     *
     * @param format the format specifier to use
     * @param args an array of Objects to be used when processing format
     *            specifiers
     * @return the resulting String
     */
    public static String psprintf(String format, Object... args)
    {
        return psprintf(format, args, true);
    }

    private static VeraPrintfFormatter formatterWithEscapes = new VeraPrintfFormatter(
        true);
    private static VeraPrintfFormatter formatterWithoutEscapes = new VeraPrintfFormatter(
        false);

    private static String psprintf(
        String format,
        final Object[] args,
        final boolean leaveEscapes)
    {
        if (leaveEscapes)
        {
            return formatterWithEscapes.sprintf(format, args);
        }
        else
        {
            return formatterWithoutEscapes.sprintf(format, args);
        }
    }

    /**
     * sprintf built-in function.
     * <P>
     * Note that the sequence "\\" is not unescaped by this function.
     *
     * @see #psprintf(String, Object[])
     * @param str the String to assign into
     * @param format the psprintf format to use
     * @param args the arguments to be used when processing the format string
     */
    public static void sprintf(JunoString str, String format, Object... args)
    {
        str.assign(psprintf(format, args, true));
    }

    /**
     * built-in sscanf function. This function takes two strings -- a
     * source string and a format string. It then tries to parse the source
     * string based on the format string, extracting various pieces based on
     * the format string.
     *
     * @param str The source string which should not contain format specifiers.
     * @param format The format string which is used to parse the source string.
     * @param args The array in which Objects matching the format specifiers of
     * the format string should be put.
     * @param types An array describing the types to which each extracted arg
     * should be converted.
     * @throws RuntimeException if the extracted object cannot be converted to
     * the desired type.
     */
    public static void sscanf(
        String str,
        String format,
        Object[] args,
        Class[] types)
    {

        // * There are no Format Specifier flags in sscanf. Vera prints
        //   a warning and ignores the specifier, continuing to evaluate the
        //   format string.
        // * sscanf will parse str and assign objects to args until a parsing
        //   mismatch occurs. at this point it will return.
        // * If sscanf detects an illegal specifier, the %<specifier> and any
        //   trailing spaces are ignored. for instance:
        //      sscanf("abd def", "%a %s", s); will assign "abd" to string s.
        // * Back to back identifiers are greedy, for instance:
        //      sscanf("1009edge", "%h%s", i, s); will assign 0x1009ed to i and
        //      "ge" to string s.
        // * Any numeric specifier can match <width>'<radix><value> notation.
        //   This doesn't not affect greediness, it will only truncate values.
        //      sscanf("4'h1009edge", "%h%s", i, s); will assign 0xd to i and
        //      "ge" to string s.
        // * A minus prefix is not allowed in w'rv notation, and will be matched
        //   as a string against str.
        // * A newline in either the str or format ends the matching.
        // * Contiguous spaces in either str or format compress down to one
        // space
        // * Contiguous tabs/newlines do not compress down to 1 tab/newline
        // * A width specifier will parse only that many characters
        //
        // If we see X parse until Y
        // %b -> any character other than [_01]
        // %o -> any character other than [_0-7]
        // %d, %u, %i -> any character other than [_-0-9]
        // %h, %x -> any character other than [_0-9A-Fa-f]
        // %s -> any tab or space (but not a newline)
        // %c -> parse exactly one character
        // any of the numeric specifiers can also parse w'rv notation

        final class SscanfException
            extends RuntimeException
        {
            private static final long serialVersionUID = 3257004371584760117L;

            SscanfException(String s)
            {
                super(s);
            }
        }

        final class SscanfStrFinder
        {
            private final String mStr;
            private final char[] mChars;
            private int mIdx;
            BitVectorFormat mFormat;

            SscanfStrFinder(String s)
            {
                mStr = s;
                mIdx = 0;

                mChars = mStr.toCharArray();
                mFormat = new BitVectorFormat();
            }

            private boolean eos()
            {
                return (mIdx >= mStr.length());
            }

            String getString(int widthSpec)
            {
                if (eos()) return "";
                // Parse until we hit the end of the string or a space character
                // Ignore any leading spaces
                StringBuffer sb = new StringBuffer();
                boolean widthReached = false;
                for (; mIdx < mChars.length && !widthReached; ++mIdx)
                {
                    char c = mChars[mIdx];
                    // there's no way to get a newline into a Vera string
                    assert (c != '\n');
                    if (c == ' ' || c == '\t' || c == '\r')
                    {
                        if (sb.length() > 0)
                            break;
                        else
                            continue;
                    }

                    sb.append(c);
                    widthReached = (widthSpec != 0 && sb.length() >= widthSpec);

                    if (widthReached && c == '\\')
                    {
                        Juno
                            .warning("WARNING: You've hit the escaped char width corner case");
                    }
                }
                return sb.toString();
            }

            BitVector getBitVector(int radix, int vectorWidth, int widthSpec)
            {
                if (eos()) return null;

                String radixPatternString = null;
                switch (radix)
                {
                case 2:
                    radixPatternString = "_01XxZz";
                    break;
                case 8:
                    radixPatternString = "_0-7XxZz";
                    break;
                case 10:
                    radixPatternString = "_0-9XxZz";
                    break;
                case 16:
                    radixPatternString = "_0-9A-Fa-fXxZz";
                    break;
                default:
                    throw new RuntimeException("Internal error. Radix = "
                        + radix);
                }

                assert (widthSpec >= 0);
                String numMatchesStr = (widthSpec == 0 ? "+" : ("{1,"
                    + widthSpec + "}"));

                // NOTE: the width/radix character matched is ignored. it can be
                // anything (e.g. sscanf("2'=400", "%d", i1)) will match 400.
                String numPatternStr = "([ \t\r]*-?(?:([0-9]+)?'(.))?(["
                    + radixPatternString + "]" + numMatchesStr + ")).*";
                Pattern numPattern = Pattern.compile(numPatternStr,
                    Pattern.DOTALL);

                String curString = mStr.substring(mIdx);
                String valueStr = null;
                Matcher matcher = numPattern.matcher(curString);
                if (!matcher.matches())
                {
                    return null;
                }

                // remove any width/radix specifier
                valueStr = matcher.group(1);
                mIdx += valueStr.length();
                valueStr = valueStr.trim().replaceFirst("^.*'.", "");
                try
                {
                    mFormat.setRadix(radix);
                    BitVector v = (vectorWidth == -1) ? mFormat.parse(valueStr)
                        : mFormat.parse(valueStr, vectorWidth);
                    return v;

                }
                catch (NumberFormatException e)
                {
                    return null;
                }
            }

            boolean match(String s)
            {
                if (eos()) return (s.length() == 0 ? true : false);

                int endIdx = Math.min(mStr.length(), (mIdx + s.length()));
                String subStr = mStr.substring(mIdx, endIdx);
                mIdx += s.length();
                return s.equals(subStr);
            }
        }

        final class FormatSpec
        {
            int widthSpec = 0;
            char specifier = '\0';

            int parseFormatSpec(char[] formatArr, int idx)
            {
                assert (formatArr[idx - 1] == '%');
                StringBuffer sb = new StringBuffer();
                int j = idx;
                outofswitch: for (; j < formatArr.length; ++j)
                {
                    switch (formatArr[j])
                    {
                    case '0': // widths
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        sb.append(formatArr[j]);
                        break;
                    case 'b': // valid specifiers
                    case 'c':
                    case 'd':
                    case 'h':
                    case 'i':
                    case 's':
                    case 'x':
                    case '%':
                        specifier = formatArr[j];
                        break outofswitch;
                    default:
                        throw new SscanfException(
                            "WARNING: Unrecognized format in sscanf, \"..."
                                + new String(formatArr).substring(idx - 1)
                                + "\"");
                    }
                }
                if (sb.length() > 0)
                {
                    widthSpec = Integer.parseInt(sb.toString());
                }
                return j;
            }
        }

        final class SscanfObjConverter
        {
            public Object convert(Object o, Class from, Class to)
            {
                assert (o != null);
                if (from == to)
                {
                    return o;
                }

                boolean fromIsBitVector = (from == BitVector.class);
                boolean fromIsString = (from == String.class);
                boolean toIsBit = (to == Bit.class);
                boolean toIsBitVector = (to == BitVector.class);
                boolean toIsString = (to == String.class);
                boolean toIsJunoString = (to == JunoString.class);
                boolean toIsInteger = (to == Integer.class);

                if (fromIsBitVector)
                {
                    BitVector v = (BitVector) o;

                    assert (!toIsBitVector);

                    if (toIsBit)
                    {
                        return v.getBit(0);
                    }
                    else if (toIsInteger)
                    {
                        return new Integer(v.intValue());
                    }
                    else if (toIsString || toIsJunoString)
                    {
                        return null;
                    }
                }
                else if (fromIsString)
                {
                    String s = (String) o;

                    assert (!toIsString);
                    assert (s.length() > 0);
                    if (toIsJunoString)
                    {
                        return new JunoString(s);
                    }
                    else if (toIsInteger)
                    {
                        return new Integer(new BitVector(s.getBytes())
                            .intValue());
                    }
                    else if (toIsBit)
                    {
                        return new BitVector(s.getBytes()).getBit(0);
                    }
                    else if (toIsBitVector)
                    {
                        return new BitVector(s.getBytes());
                    }
                }
                throw new RuntimeException("Unsupported conversion: " + from
                    + " -> " + to);
            }
        }

        if (str == null)
        {
            throw new RuntimeException("null string passed to sscanf");
        }

        int curArg = 0;
        SscanfObjConverter converter = new SscanfObjConverter();
        SscanfStrFinder finder = new SscanfStrFinder(str);
        char[] formatChars = format.toCharArray();
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < formatChars.length; ++i)
        {

            boolean isFormatDelimeter = (formatChars[i] == '%' || formatChars[i] == ' ');
            if (isFormatDelimeter)
            {
                // match anything we've found up to this point.
                if (!finder.match(sb.toString()))
                {
                    // mismatch. outta here.
                    return;
                }
                else
                {
                    sb.setLength(0);
                }
            }

            if (formatChars[i] == '%')
            {
                // make sure there's a character left to parse
                ++i;
                if (i >= formatChars.length) break;

                boolean foundMatch = false;
                Object matchedObj = null;

                // get format specifier
                FormatSpec fSpec = new FormatSpec();
                try
                {
                    // the parser will eat up some of the char buffer, so
                    // update i with the new value.
                    i = fSpec.parseFormatSpec(formatChars, i);
                }
                catch (SscanfException e)
                {
                    System.err.println(e.getMessage());
                    continue;
                }

                int width = -1;
                if (types[curArg] == Integer.class)
                {
                    width = 32;
                }
                else if (types[curArg] == Bit.class)
                {
                    width = 1;
                }
                else if (types[curArg] == BitVector.class
                    && args[curArg] != null)
                {
                    width = ((BitVector) args[curArg]).length();
                }

                switch (fSpec.specifier)
                {
                case '%':
                    foundMatch = finder.match("%");
                    break;
                case 'c':
                    matchedObj = finder.getString(1);
                    break;
                case 's':
                    matchedObj = finder.getString(fSpec.widthSpec);
                    break;
                case 'b':
                    matchedObj = finder.getBitVector(2, width, fSpec.widthSpec);
                    break;
                case 'o':
                    matchedObj = finder.getBitVector(8, width, fSpec.widthSpec);
                    break;
                case 'd':
                case 'i':
                    matchedObj = finder
                        .getBitVector(10, width, fSpec.widthSpec);
                    break;
                case 'h':
                case 'x':
                    matchedObj = finder
                        .getBitVector(16, width, fSpec.widthSpec);
                    break;
                default:
                    throw new RuntimeException(
                        "Internal error -- unhandled specifier: "
                            + Integer.toHexString(fSpec.specifier));
                }

                foundMatch = (foundMatch | (matchedObj != null));

                if (!foundMatch)
                {
                    // mismatch. we're done.
                    return;
                }
                else if (matchedObj != null)
                {
                    Object convertedObj = converter.convert(matchedObj,
                        matchedObj.getClass(), types[curArg]);

                    assert (curArg < args.length);

                    // assign this only if we're supposed to.
                    if (convertedObj != null)
                    {
                        args[curArg] = convertedObj;
                    }
                    ++curArg;
                    matchedObj = null;

                    if (curArg >= args.length)
                    {
                        // nothing else to match.
                        return;
                    }
                }
            }
            else if (formatChars[i] == ' ')
            {
                continue;
            }
            else
            {
                sb.append(formatChars[i]);
            }
        }
    }

    ////////////////////////////////////////////////////////////
    // I/O utilities
    ////////////////////////////////////////////////////////////
    public static final int VERBOSE = 4;
    public static final int SILENT = 0;
    public static final int RAWIN = 1;

    private static final Map<Integer, RandomAccessFile> randomAccessFileMap = new HashMap<Integer, RandomAccessFile>();

    private static int errorFlag = OFF;

    private static final Map<RandomAccessFile, Boolean> feofMap = new HashMap<RandomAccessFile, Boolean>();

    // key is RandomAccessFile or Integer (for standard I/O descriptors)
    private static final Map<Object, Boolean> ferrorMap = new HashMap<Object, Boolean>();

    // list of lock files held by this JVM
    private static final List<String> flockFileList = new LinkedList<String>();

    static final int STDIN = 1;
    static final int STDOUT = 2;
    static final int STDERR = 3;
    private static final int MIN_FILE_DESC = 4;
    private static int curFileDesc = MIN_FILE_DESC;

    /**
     * printf built-in function.
     * <P>
     * This method prints the results of psprintf(format, args) to
     * {@link java.lang.System#out}.
     *
     * @see #psprintf(String, Object[])
     * @param format the psprintf format to use
     * @param args the arguments to be used when processing the format string
     */
    public static void printf(String format, Object... args)
    {
        System.out.print(psprintf(format, args, false));
    }

    /**
     * fopen built-in function
     * <P>
     * This method opens a file in a given mode and returns an file descriptor
     * suitable for passing to other file I/O methods. It calls
     * {@link #fopen(String,String,int)} with a third parameter of
     * {@link #VERBOSE}.
     *
     * @param filename the name of the file to open
     * @param mode one of "r", "w", or "a"
     * @return a file descriptor
     */
    public static int fopen(String filename, String mode)
    {
        return fopen(filename, mode, Juno.VERBOSE);
    }

    /**
     * fopen built-in function
     * <P>
     * This method opens a file in a given mode and returns an file descriptor
     * suitable for passing to other file I/O methods.
     * <P>
     * Some notes:
     * <ul>
     * <li>Legal Modes
     * <ul>
     * <li>"r": open the file for reading
     * <li>"w": open the file for writing, truncating if the file exists,
     * creating it otherwise.
     * <li>"a": open the file for writing, appending to it if the file exists,
     * creating it otherwise.
     * <li>all other characters are illegal
     * </ul>
     * <li>Implementation Details
     * <ul>
     * <li>The legal mode characters are read in order. The first legal
     * character is the mode used.
     * <li>If an illegal character comes after a legal character it is ignored
     * even with VERBOSE specified.
     * <li>Legal characters can be repeated without errors
     * <li>If an illegal character is the first character in mode, fopen will
     * fail and return a 0. if VERBOSE is enabled, an error message with stack
     * trace is dumped, and program execution continues
     * </ul>
     * </ul>
     *
     * @param filename the name of the file to open
     * @param mode one of "r", "w", or "a"
     * @param verbose one of {@link #VERBOSE}or {@link #SILENT}
     * @return a file descriptor
     */
    public static int fopen(String filename, String mode, int verbose)
    {
        assert (verbose == VERBOSE || verbose == SILENT);

        int modeIdx = -1;
        Pattern arw = Pattern.compile(".*?([arw]).*?");
        Matcher matcher = arw.matcher(mode);
        if (matcher.matches())
        {
            modeIdx = matcher.start(1);
        }
        boolean errorDetected = false;
        int fid = 0;

        if (modeIdx == -1 || (modeIdx > 0 && verbose == VERBOSE))
        {
            errorDetected = true;
        }
        else
        {
            RandomAccessFile file = null;
            if (mode.charAt(modeIdx) == 'r')
            {
                try
                {
                    // mode 'r'
                    file = new RandomAccessFile(filename, "r");
                }
                catch (FileNotFoundException e)
                {
                    errorDetected = true;
                }
            }
            else
            {
                try
                {
                    file = new RandomAccessFile(filename, "rw");
                    if (mode.charAt(modeIdx) == 'a')
                    {
                        // mode 'a'
                        file.seek(file.length() - 1);
                    }
                    else
                    {
                        // mode 'w'
                        file.getChannel().truncate(0);
                    }
                }
                catch (FileNotFoundException e)
                {
                    errorDetected = true;
                }
                catch (IOException e)
                {
                    errorDetected = true;
                }
            }

            if (!errorDetected)
            {
                fid = curFileDesc;
                //{
                //    File f = new File(filename);
                //    System.out.println("fopen[" + fid + "]: (" + mode + ") "
                //        + f.getAbsolutePath());
                //}
                randomAccessFileMap.put(fid, file);
                ++curFileDesc;
            }
        }

        if (errorDetected)
        {
            System.err.println("fopen failed. filename=" + filename + ", mode="
                + mode);
            dumpStack(System.err);
            return 0;
        }
        else
        {
            return fid;
        }
    }

    /**
     * fclose built-in function.
     * <P>
     * Closes the file descriptor fd. If fd is an invalid descriptor, this
     * method silently succeeds. Attempts to close built in the streams,
     * {@link #STDIN},{@link #STDOUT}, and {@link #STDERR}are ignored.
     *
     * @param fd the file descriptor to close
     */
    public static void fclose(int fd)
    {
        if (fd == 0)
        {
            throw new RuntimeException("fclose failed due to invalid "
                + "file descriptor [0]");
        }

        if (fd < MIN_FILE_DESC) return;

        Integer mapID = new Integer(fd);
        RandomAccessFile file = randomAccessFileMap.get(mapID);
        if (file != null)
        {
            try
            {
                file.close();
            }
            catch (IOException e)
            {
                // Vera seems to just drop errors on the floor
            }
            finally
            {
                // System.out.println("fclose[" + fd + "]");
                randomAccessFileMap.put(mapID, null);
            }
        }
    }

    /**
     * fprintf built-in function.
     * <P>
     * This method prints the results of psprintf(format, args) to the file
     * described by fd.
     * <P>
     * If fd is invalid or is {@link #STDIN}, a RuntimeException occurs.
     * Further, if fd has been opened in read mode, the call to fprintf is
     * ignored and the ferror status for fd is set to true.
     *
     * @see #psprintf(String, Object[])
     * @param fd the file descriptor to which to write
     * @param format the fprintf format to use
     * @param args the arguments to be used when processing the format string
     */

    public static void fprintf(int fd, String format, Object... args)
    {
        if (fd == 0)
        {
            throw new RuntimeException("fprintf failed due to invalid "
                + "file descriptor [0]");
        }

        String str = psprintf(format, args, false);
        if (fd < MIN_FILE_DESC)
        {
            if (fd == STDOUT)
            {
                System.out.print(str);
            }
            else if (fd == STDERR)
            {
                System.err.print(str);
            }
            else
            {
                throw new RuntimeException("ERROR: fprintf on stdin");
            }
            return;
        }

        RandomAccessFile file = randomAccessFileMap.get(new Integer(fd));
        if (file == null)
        {
            throw new RuntimeException("fprintf failed due to invalid"
                + " file descriptor [" + fd + "]");
        }
        try
        {
            file.write(str.getBytes());
        }
        catch (IOException e)
        {
            ferrorMap.put(file, Boolean.TRUE);
            // Vera silently ignores writing to a file with mode 'r', but marks
            // the fd as having an error
        }

    }

    // exception used to communicate b/t readLine and fread* methods
    private static class JunoFileIOException
        extends RuntimeException
    {
        private static final long serialVersionUID = 3256444685806219829L;
        private boolean isWarning;

        public JunoFileIOException(String s)
        {
            super(s);
            this.isWarning = false;
        }

        public JunoFileIOException(String s, boolean isWarning)
        {
            super(s);
            this.isWarning = isWarning;
        }

        public boolean isWarning()
        {
            return isWarning;
        }
    }

    // a private method which returns a line from the given file descriptor
    private static String readLine(int fd, int mode)
    {
        assert (mode == VERBOSE || mode == SILENT || mode == RAWIN);
        InputStream istream = null;
        RandomAccessFile file = null;
        boolean useIstream = false;

        if (fd == 0)
        {
            throw new JunoFileIOException("failed due to invalid "
                + " file desriptor fd=0");
        }

        if (fd < MIN_FILE_DESC)
        {
            if (fd == STDIN)
            {
                istream = System.in;
                useIstream = true;
            }
            else
            {
                throw new JunoFileIOException("trying to read on "
                    + (fd == STDOUT ? "STDOUT" : "STDERR"));
            }
        }
        else
        {
            file = randomAccessFileMap.get(fd);
            if (file == null)
            {
                throw new JunoFileIOException("failed due to invalid"
                    + " file descriptor fd=" + fd);
            }
            if (feofMap.containsKey(file) && feofMap.get(file))
            {
                // VERBOSE prints a warning and sets the EOF and error flags
                // SILENT/RAWIN only set the EOF flag
                if (mode == VERBOSE)
                {
                    errorFlag |= ON;
                    throw new JunoFileIOException("detected EOF", true);
                }
                else
                {
                    // SILENT just returns a null string
                    return null;
                }
            }
        }

        StringBuffer buf = new StringBuffer(80); // default to 80 char line
        try
        {
            char c = 0;
            boolean shouldIgnore = false;
            String s = null;
            do
            {
                shouldIgnore = false;
                do
                {
                    int signedChar = -1;
                    if (useIstream)
                    {
                        signedChar = istream.read();
                        if (signedChar == -1)
                        {
                            throw new EOFException();
                        }
                        c = (char) signedChar;
                    }
                    else
                    {
                        c = (char) file.readByte();
                    }
                    if (c == '\n')
                    {
                        break;
                    }

                    buf.append(c);
                }
                while (true);

                s = buf.toString();

                if (mode == RAWIN)
                {
                    // RAWIN takes any line, even a blank one.
                    break;
                }
                else
                {
                    // in VERBOSE/SILENT mode, lines containing only
                    // whitespace or comments are ignored
                    s = s.replaceFirst("//.*", ""); // // comments
                    s = s.replaceAll("/\\*.*?\\*/", ""); // /*...*/ comments
                    if (s.trim().length() == 0)
                    {
                        shouldIgnore = true;
                        buf.delete(0, buf.length());
                    }
                }
            }
            while (shouldIgnore);

            return s;
        }
        catch (EOFException eof)
        {
            assert (!useIstream); // assume there can not be EOF on stdin
            feofMap.put(file, Boolean.TRUE);

            return null;
        }
        catch (IOException ie)
        {
            // we should never see an IOException at this point
            throw new RuntimeException(ie);
        }
    }

    /**
     * Reads a binary value from a file and returns the corresponding BitVector.
     * Comments and lines containing only whitespace are ignored. If the mode is
     * VERBOSE, a message will be printed when the end of file is detected.
     * <P>
     * Each valid line of the file should correspond to the regular expression:
     * ([01_])+
     *
     * @param fd The file descriptor from which to read.
     * @param mode One of {@link #VERBOSE} or {@link #SILENT}
     * @return a BitVector having the value of the binary value read from the
     * file or null if an error occurs.
     */
    public static BitVector freadb(int fd, int mode)
    {
        assert (mode == VERBOSE || mode == SILENT);
        try
        {
            String s = readLine(fd, mode);
            if (s == null || s.trim().length() == 0)
            {
                return new BitVector(64, 0);
            }

            s = s.trim(); // get rid of leading whitespace
            s = s.replaceFirst("\\s.*", ""); // get ride of trailing comments
            s = s.replaceAll("_", ""); // get rid of underscores (for length calculation)
            return new BitVector("'b" + s, s.length());
        }
        catch (JunoFileIOException e)
        {
            if (e.isWarning())
            {
                warning("WARNING: freadb " + e.getMessage());
                return null;
            }

            throw new RuntimeException("freadb: " + e.getMessage());
        }
    }

    /**
     * Reads a hexadecimal value from a file and returns the corresponding BitVector.
     * Comments and lines containing only whitespace are ignored. If the mode is
     * VERBOSE, a message will be printed when the end of file is detected.
     * <P>
     * Each valid line of the file should correspond to the regular expression:
     * ([A-Za-z0-9_])+
     *
     * @param fd The file descriptor from which to read.
     * @param mode One of {@link #VERBOSE} or {@link #SILENT}
     * @return a BitVector having the value of the hexadecimal value read from
     * the file or null if an error occurs.
     */
    public static BitVector freadh(int fd, int mode)
    {
        assert (mode == VERBOSE || mode == SILENT);
        try
        {
            String s = readLine(fd, mode);
            if (s == null || s.trim().length() == 0)
            {
                return new BitVector(64, 0);
            }

            s = s.trim(); // get rid of leading whitespace
            s = s.replaceFirst("\\s.*", ""); // get ride of trailing comments
            s = s.replaceAll("_", ""); // get rid of underscores (for length calculation)
            return new BitVector("'h" + s, s.length() * 4);
        }
        catch (JunoFileIOException e)
        {
            if (e.isWarning())
            {
                warning("WARNING: freadh " + e.getMessage());
                return null;
            }

            throw new RuntimeException("freadh: " + e.getMessage());
        }
    }

    /**
     * freadstr built-in function.
     * <P>
     * This call is equivalent to freadstr(fd, Vera.VERBOSE);
     * <P>
     * @see #freadstr(int, int)
     * @param fd
     * @return the string read from the file
     */
    public static String freadstr(int fd)
    {
        return freadstr(fd, Juno.VERBOSE);
    }

    /**
     * freadstr built-in function.
     * <P>
     * Read a line from a file and return it as a String.
     * <P>
     * <ul>
     * Modes
     * <li>{@link #VERBOSE}Upon reaching EOF, a warning is printed and a null
     * string is returned.
     * <li>{@link #SILENT}Upon reaching EOF, a null string is returned, but no
     * warning is printed.
     * <li>{@link #RAWIN}Identical to SILENT except blank lines and comments
     * are not filtered out.
     * </ul>
     * Both VERBOSE and SILENT modes will filter out lines containing only
     * whitespace and comments. All modes will set the ferror status of fd to
     * true upon reaching the end of file.
     * <P>
     * Passing an invalid file descriptor or a file descriptor that was not
     * opened in read mode will result in a RuntimeException.
     *
     * @param fd the file descriptor from which to read
     * @param mode one of {@link #VERBOSE},{@link #SILENT}, or {@link #RAWIN}
     * @return the string read from the file
     */
    public static String freadstr(int fd, int mode)
    {
        // TODO: freadstr ensure reading from STDOUT/STDERR errors appropriately
        // TODO: make sure multiline C-style comments are filtered properly
        assert (mode == VERBOSE || mode == SILENT || mode == RAWIN);
        try
        {
            return readLine(fd, mode);
        }
        catch (JunoFileIOException e)
        {
            if (e.isWarning())
            {
                warning("WARNING: freadstr " + e.getMessage());
                return null;
            }

            throw new RuntimeException("freadstr: " + e.getMessage());
        }
    }

    /**
     * fflush built-in function.
     * <P>
     * Flush any buffered output to the file described by fd.
     * <P>
     * If fd describes a file opened in read mode or {@link #STDIN}, fflush
     * returns immediately. If fd is invalid, a RuntimeException is thrown.
     *
     * @param fd the file descriptor to flush
     */
    public static void fflush(int fd)
    {
        // fflush
        // * vera silently ignores fflush calls to input streams (inc. stdin)
        // * vera dumps stack and dies if fd is not a valid file descriptor

        if (fd == 0)
        {
            throw new RuntimeException("fflush failed due to invalid"
                + " file descriptor [0]");
        }

        if (fd < MIN_FILE_DESC)
        {
            if (fd == STDOUT)
                System.out.flush();
            else if (fd == STDERR) System.err.flush();
            return;
        }

        RandomAccessFile file = randomAccessFileMap.get(fd);
        if (file == null)
        {
            throw new RuntimeException("fflush failed due to invalid"
                + " file descriptor [" + fd + "]");
        }
        else
        {
            try
            {
                file.getChannel().force(false);
            }
            catch (IOException e)
            {
                // Vera silently ignores flushes to input streams and does not
                // mark them as having an error
            }
        }
    }

    /**
     * rewind built-in function.
     * <P>
     * Returns the file pointer associated with fd to the beginning of the file.
     * <P>
     * For {@link #STDIN},{@link #STDOUT}, and {@link #STDERR}, this method
     * returns immediately. If fd is an invalid file descriptor, a
     * RuntimeException is thrown.
     * <P>
     * Calling this method clears the ferror status of fd. This is the only way
     * to clear this error status, short of closing the file and reopening it.
     *
     * @param fd the file descriptor to rewind.
     */
    public static void rewind(int fd)
    {
        // rewind
        // * vera seems to do nothing for built-in streams (stdin, out, err)
        // * vera dumps stack and dies if fd is not a valid file descriptor
        // * vera clears ferror status for fd when rewind() is called

        if (fd == 0)
        {
            throw new RuntimeException("rewind failed due to invalid "
                + " file desriptor [0]");
        }

        if (fd < MIN_FILE_DESC)
        {
            Integer i = new Integer(fd);
            assert (!feofMap.containsKey(i));
            ferrorMap.put(i, Boolean.FALSE);
            return;
        }

        RandomAccessFile file = randomAccessFileMap.get(fd);
        if (file == null)
        {
            throw new RuntimeException("rewind failed due to invalid"
                + " file descriptor [" + fd + "]");
        }
        else
        {
            try
            {
                file.seek(0);
                // rewind clears ferror() status
                feofMap.put(file, Boolean.FALSE);
                ferrorMap.put(file, Boolean.FALSE);
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * lock_file built-in function.
     * <P>
     * Locks a file for use by this JVM only.
     * <P>
     * lock_file creates a file, &lt;filename&gt;.lock_file any further attempts
     * to lock the file by the same process are successful. attempts by another
     * process to lock the file will block timeout seconds, or forever if
     * timeout == 0. further, if &lt;filename&gt;.lock_file exists but is empty,
     * the lock_file attempt times out or blocks as specified by the timeout
     * parameter. if filename is a directory, the lock file is written in the
     * parent directory of the dir. if write access is not allowed in that
     * directory, a RuntimeException is thrown.
     * <P>
     * Note: This implementation does not use PIDs as they aren't really used by
     * Vera anyway
     *
     * @see #unlock_file(String)
     * @param filename the name of the file to lock
     * @param timeout the timeout value in seconds, or 0 for no timeout.
     * @return true if the file was locked, false if a timeout occurred
     */
    public static boolean lock_file(String filename, int timeout)
    {
        try
        {
            // Get a file channel for the file
            int count = 0;
            long baseTimeStamp = 0;
            long curTimeStamp = 0;

            File fd = new File(filename + ".lock_file");
            RandomAccessFile file = new RandomAccessFile(fd, "rw");

            while (fd.exists())
            {
                if (flockFileList.contains(filename))
                {
                    return true;
                }

                file.close();
                if (count < timeout)
                {
                    return false;
                }

                // Sleep for 1 second (even if interrupted)
                curTimeStamp = System.currentTimeMillis();
                baseTimeStamp = curTimeStamp + 1000;
                while (curTimeStamp < baseTimeStamp)
                {
                    try
                    {
                        Thread.sleep(baseTimeStamp - curTimeStamp);
                    }
                    catch (InterruptedException e)
                    {
                        curTimeStamp = System.currentTimeMillis();
                    }
                }
                file = new RandomAccessFile(fd, "rw");
                ++count;
            }

            // create the lockfile
            file.close();
            flockFileList.add(filename);
            return true;
        }
        catch (FileNotFoundException e)
        {
            throw new RuntimeException("cound not create lockfile for: "
                + filename);
        }
        catch (IOException e)
        {
            throw new RuntimeException("cound not create lockfile for: "
                + filename);
        }
    }

    /**
     * unlock_file built-in function
     * <P>
     * unlock_file removes &lt;filename&gt;.lock_file, even if it is not the
     * locking JVM.
     * <P>
     * Note: Vera puts its UNIX PID in the lockfile. Then when lock_file() is
     * called, if the lockfile exists, and the PID doesn't match, the lock
     * blocks. However, any UNIX PID can call unlock_file on the file and remove
     * the lockfile. This would make the whole business of putting the PID in
     * the file moot. For this reason, PIDs are not used in this implementation.
     * <P>
     *
     * @see #lock_file(String, int)
     * @param filename the filename to unlock
     */
    public static void unlock_file(String filename)
    {
        File fd = new File(filename + ".lock_file");
        if (fd.exists())
        {
            if (!fd.delete())
            {
                throw new RuntimeException("Cannot remove lock file for: "
                    + filename);
            }
        }
        flockFileList.remove(filename);
    }

    /**
     * feof built-in function.
     * <P>
     * Check if fd is at the end of the file.
     * <P>
     * Notes: These are valid as of Vera 6.2.15. Vera dumps stack and dies if fd ==
     * STDIN
     * <P>
     * Vera behaves strangely if fd == STDOUT || fd == STDERR:
     *
     * <pre>
     *   integer foo = feof([23]); // this SIGSEGVs
     *   printf(&quot;%0d\n&quot;, feof([23])); // this prints a cryptic printf err
     * </pre>
     *
     * <P>
     * Vera dumps stack and dies if fd is not a valid file descriptor
     * <P>
     * This implementation returns false if fd is STDIN, STDOUT, or STDERR. If
     * fd is an invalid descriptor, a RuntimeException is thrown. If fd
     * describes a file not opened in read mode, false is returned.
     *
     * @param fd the file descriptor on which to check for the EOF condition
     * @return true if the file described by fd is at the end of file, false
     *         otherwise.
     */
    public static boolean feof(int fd)
    {
        // feof
        if (fd == 0)
        {
            throw new RuntimeException("feof failed due to invalid"
                + " file descriptor [" + fd + "]");
        }

        if (fd < MIN_FILE_DESC)
        {
            if (fd == STDIN)
            {
                throw new RuntimeException("ERROR: feof on stdin");
            }

            // Vera core dumps on:
            // integer foo = feof(stdout|stderr)
            // but dies gracefully (if cryptically) on
            // printf("%0d\n", feof(stdout|stderr);
            // We'll just do what Vera does for "regular" write streams
            return false;
        }

        RandomAccessFile file = randomAccessFileMap.get(fd);
        if (file == null)
        {
            throw new RuntimeException("feof failed due to invalid"
                + " file descriptor [" + fd + "]");
        }

        if (!feofMap.containsKey(file))
        {
            feofMap.put(file, Boolean.FALSE);
        }
        return feofMap.get(file);
    }

    /**
     * ferror built-in function
     * <P>
     * This method returns the ferror status of a file descriptor.
     * <P>
     * A file descriptors ferror status becomes true when
     * <ul>
     * <li>EOF is reached during {@link #freadb},{@link #freadh}, or
     * {@link #freadstr(int, int)}where {@link #SILENT}mode was not used and
     * the file descriptor in question was opened in read mode.
     * <li>{@link #freadb},{@link #freadh}, or {@link #freadstr(int, int)}
     * was called with a file descriptor which was not opened in read mode
     * <li>an attempt is made to write to an input stream
     * </ul>
     * A file descriptors ferror status becomes false when
     * <ul>
     * <li>the file is first opened
     * <li>{@link #rewind}is called on the file descriptor
     * </ul>
     * <P>
     * If fd is an invalid file descriptor, a RuntimeException will be thrown.
     *
     * @param fd the file descriptor on which to check for ferror status
     * @return true if an error has occurred on the file descriptor, false
     *         otherwise
     */
    public static boolean ferror(int fd)
    {
        Object key = null;
        if (fd == 0)
        {
            throw new RuntimeException("ferror failed due to invalid"
                + " file descriptor [" + fd + "]");
        }

        if (fd < MIN_FILE_DESC)
        {
            key = new Integer(fd);
        }
        else
        {
            key = randomAccessFileMap.get(fd);
            if (key == null)
            {
                throw new RuntimeException("ferror failed due to invalid"
                    + " file descriptor [" + fd + "]");
            }
        }

        if (!ferrorMap.containsKey(key))
        {
            ferrorMap.put(key, Boolean.FALSE);
        }
        return ferrorMap.get(key);
    }

    ////////////////////////////////////////////////////////////
    // Error utilities
    ////////////////////////////////////////////////////////////

    public static void warning(String warning)
    {
        System.err.println(warning);
    }

    /**
     * error built-in function.
     * <P>
     * This function prints the string generated by psprintf(format, args) to
     * System.err and throws a RuntimeException.
     *
     * @param format The format specifier to pass to psprintf
     * @param args The arguments for any format specifiers in format
     * @throws RuntimeException containing the formatted message
     */
    public static void error(String format, Object... args)
    {
        String msg = psprintf(format, args, false);
        System.err.print(msg);
        throw new RuntimeException(msg);
    }

    /**
     * NOTE: error_mode is currently unsupported.
     * @param enable
     * @param ec
     */
    public static void error_mode(int enable, int ec)
    {
        // TODO: error_mode
        throw new UnsupportedOperationException("error_mode is not implemented");
    }

    /**
     * Returns the status of the internal flag variable.
     * @return the flag status
     */
    public static int flag()
    {
        assert (errorFlag == ON || errorFlag == OFF);
        return errorFlag;
    }

    /**
     * Sets and gets the status of the internal flag variable. If enable == -1,
     * the current flag status is returned. Otherwise, the flag is turned on or
     * off as specified by enable and the <i>previous</i> flag status is returned.
     *
     * @param enable on of either {@link #ON}, {@link #OFF}, or -1
     * @return the flag status
     */
    public static int flag(int enable)
    {
        // a -1 means that the argument is omitted.
        // TODO: remove the -1 support once the translator supports the argument-less version
        if (enable == -1)
        {
            return flag();
        }

        assert (enable == ON || enable == OFF);
        int curFlag = errorFlag;
        errorFlag = enable;
        return curFlag;
    }

    ////////////////////////////////////////////////////////////
    // System interaction utilities
    ////////////////////////////////////////////////////////////

    public static final int LO = 0;
    public static final int HI = 1;

    /**
     * Get the current DV.simulation time in ticks. Since the current DV.simulation
     * time is a 64 bit quantity and this function only returns an int, it takes
     * a parameter, part, that determines whether the high or low 32 bits of the
     * current time are returned.
     *
     * @param part One of {@link #LO} or {@link #HI}
     * @return The low or high 32 bits of the current DV.simulation time as specified
     * by param.
     */
    public static int get_time(int part)
    {
        assert (part == LO || part == HI);
        long simTime = DV.simulation.getSimTime();
        return (part == HI) ? (int) (simTime >> 32) : (int) simTime;
    }

    /**
     * Returns the current DV.simulation wall-clock time in seconds.
     * @return the wall-clock time of the DV.simulation in seconds.
     */
    public static int get_systime()
    {
        return (int) (System.currentTimeMillis() / 1000);
    }

    /**
     * Block the current thread until the specified number of ticks have occurred.
     *
     * @param ticks The number of ticks to wait before resuming this thread.
     */
    public static void delay(int ticks)
    {
        DV.simulation.delay(ticks);
    }

    /**
     * Run a command outside of the Jove environment.
     *
     * @param command A String containing the full command to run.
     * @return The exit value of the command.
     * @throws RuntimeException if an error occurs running the command
     */
    public static int os_command(final String command)
    {
        final boolean debugMode = false;
        final String osName = System.getProperty("os.name");
        if (debugMode)
        {
            System.out.println("os.name: " + osName);
        }

        final String[] args = new String[3];
        if (osName.startsWith("Windows 9"))
        {
            args[0] = "command.com";
            args[1] = "/C";
        }
        else if (osName.startsWith("Windows"))
        {
            args[0] = "cmd.exe";
            args[1] = "/C";
        }
        else
        {
            args[0] = "/bin/sh";
            args[1] = "-c";
        }
        args[2] = command;
        if (debugMode)
        {
            System.out.println("Executing: " + TextUtil.toString(args));
        }

        try
        {
            final Runtime runtime = Runtime.getRuntime();
            final Process process = runtime.exec(args);
            SystemUtil.echoProcess(process);
            final int exitValue = process.waitFor();
            return exitValue;
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
        catch (InterruptedException ie)
        {
            throw new RuntimeException(ie);
        }
    }

    /**
     * Exit the DV.simulation with the given exit status.
     *
     * @param status the exit status
     */
    public static void exit(int status)
    {
        System.out.println("exit_status: " + status);
        // TODO: find a way to pass the exit status to the simulator
        DV.simulation.finish();
        DV.simulation.terminateAll();
    }

    ////////////////////////////////////////////////////////////
    // Random number generation utilities
    ////////////////////////////////////////////////////////////

    // Rand48 does not adhere to random stability
    private static PRNG rand48 = LinearCongruentialFactory.INSTANCE
        .newInstance();

    //	  TBD: figure out how to seed this. we need DV.simulation to be non-null and
    //         to be in a SimulationThread.
    //    {
    //        if (!get_plus_arg(CHECK, "+vera_random_seed=").isZero())
    //        {
    //            srandom(get_plus_arg(NUM, "+vera_random_seed=").intValue());
    //        }
    //        else
    //        {
    //            srandom(1);
    //        }
    //        simInitialized = true;
    //    }

    /**
     * Creates a new random number generator for the DV.simulation and seeds it with
     * the given value.
     *
     * @param seed the value with which to seed the PRNG.
     */
    public static void srandom(int seed)
    {
        PRNG newRng = PRNGFactoryFactory.getDefaultFactory().newInstance(seed);
        DV.simulation.setRandom(newRng);
    }

    /**
     * Creates a new random number generator for the DV.simulation and seeds it with
     * the given value. It then associates that random number generated with the
     * given JunoObject.
     *
     * @param seed the value with which to seed the PRNG.
     * @param obj the object with which the new random number generator should be
     * associated.
     */
    public static void srandom(int seed, JunoObject obj)
    {
        PRNG newRng = PRNGFactoryFactory.getDefaultFactory().newInstance(seed);
        obj.setRandom(newRng);
    }

    /**
     * Return a 32 bit signed random value.
     * @return a 32 bit signed random value.
     */
    public static int random()
    {
        PRNG rng = DV.simulation.getRandom();
        // Return a 31 bit positive value
        return Math.abs(rng.nextBits(32));
    }

    /**
     * Seeds the random number generator and then returns a 32 bit signed rand
     * value. This is equivalent to:
     * <P>
     * srandom(seed); random();
     *
     * @param seed the value with which to seed the PRNG.
     * @return a 32 bit signed random value.
     */
    public static int random(int seed)
    {
        srandom(seed);
        return random();
    }

    /**
     * Returns a 32 bit unsigned random value.
     * @return a 32 bit unsigned random value
     */
    public static BitVector urandom()
    {
        return new BitVector(32, random());
    }

    /**
     * Seeds the random number generator and then returns a 32 bit unsigned rand
     * value. This is equivalent to:
     * <P>
     * srandom(seed); urandom();
     *
     * @param seed the value with which to seed the PRNG.
     * @return a 32 bit unsigned random value.
     */
    public static BitVector urandom(int seed)
    {
        srandom(seed);
        return urandom();
    }

    /**
     * Returns a 32 bit signed random value generated using a 48 bit linear
     * congruential algorithm.
     * @return a 32 bit signed random value.
     */
    public static int rand48()
    {
        int randInt = rand48.nextInt();

        // rand48() should only yield positive ints.
        assert (randInt >= 0);
        return randInt;
    }

    /**
     * Seeds the 48 bit linear congruential random number generator and then
     * returns a 32 bit signed rand value generated from it.
     *
     * @param seed the value with which to seed the PRNG.
     * @return a 32 bit signed random value.
     */
    public static int rand48(int seed)
    {
        rand48 = LinearCongruentialFactory.INSTANCE.newInstance(seed);
        return rand48();
    }

    /**
     * Returns a 32 bit unsigned random value generated using a 48 bit linear
     * congruential algorithm.
     * @return a 32 bit unsigned random value.
     */
    public static BitVector urand48()
    {
        return new BitVector(32, rand48.nextInt());
    }

    /**
     * Seeds the 48 bit linear congruential random number generator and then
     * returns a 32 bit unsigned rand value generated from it.
     *
     * @param seed the value with which to seed the PRNG.
     * @return a 32 bit unsigned random value.
     */
    public static BitVector urand48(int seed)
    {
        rand48 = LinearCongruentialFactory.INSTANCE.newInstance(seed);
        return urand48();
    }

    /**
     * Returns a 32 bit unsigned random value between 0 and maxval, inclusive.
     * If maxval is > 32 bits, only the bottom 32 bits will be used.
     *
     * @param maxval The maximum value which the return value can assume.
     * @return a 32 bit unsigned random value between 0 and maxval, inclusive.
     */
    public static BitVector urandom_range(BitVector maxval)
    {
        return urandom_range(maxval, new BitVector(32, 0));
    }

    /**
     * Returns a 32 bit unsigned random value between minval and maxval, inclusive.
     * If maxval or minval is > 32 bits, only the bottom 32 bits will be used.
     *
     * @param maxval The maximum value which the return value can assume.
     * @param minval The minimum value which the return value can assume.
     * @return a 32 bit unsigned random value between minval and maxval, inclusive.
     */
    public static BitVector urandom_range(BitVector maxval, BitVector minval)
    {
        // Vera allows maxval and minval to be reversed, however
        // PRNGWrapper.nextInt() does not. Vera prints a warning so we will too.
        if (maxval.compareTo(minval) < 0)
        {
            Juno.warning("WARNING: urandom_range: maxval(" + maxval
                + ") is less than minval (" + minval + ")");
            Juno.warning("\tAutomatically reversing the range");
            BitVector tmp = minval;
            minval = maxval;
            maxval = tmp;
        }

        // Even if minval/maxval are > 32'hFFFF_FFFF, just use the bottom 32
        // bits. this is consistent with Vera.
        return new BitVector(32, DV.simulation.getRandom().nextInt(
            minval.intValue(), maxval.intValue()));
    }

    /**
     * Choose a value based on a weighted randomization. Each index in the
     * weights array has a value associated with it. This function will randomly
     * choose an index in weights with each index having a weighting equal to
     * its value.
     * <P>
     * As an example if weights is {25, 0, 50}, 0 will be returned 33% of the time,
     * 1 will be returned 0% of the time, and 2 will be returned 67% of the time.
     * @param weights an array in which each index is the weighting of that index.
     * @return an index of the array, chosen randomly by weight.
     */
    public static int randcase(int... weights)
    {
        int cases = weights.length;

        // calculate sum of weights
        int sum = 0;
        for (int i = 0; i < cases; ++i)
        {
            assert (weights[i] >= 0) : "randcase weights must be non-negative";
            sum += weights[i];
        }
        if (sum <= 0)
        {
            throw new RuntimeException("Non-positive total weight in randcase");
        }

        int rand = random() % sum;
        int count = 0;
        for (int i = 0; i < cases; ++i)
        {
            count += weights[i];
            if (rand < count) return i;
        }
        assert false;
        return 0;
    }

    ////////////////////////////////////////////////////////////
    // Signal property accessors
    ////////////////////////////////////////////////////////////

    /**
     * Check if a signal is bound to the design.
     *
     * @param signal The signal to check.
     * @return true if the signal is non-null, false otherwise.
     */
    public static boolean vera_is_bound(Signal signal)
    {
        return signal != null;
    }

    /**
     * Return a signal's name.
     * @param signal The signal to check.
     * @return The name of the given signal.
     */
    public static String vera_get_name(Signal signal)
    {
        return signal.getName();
    }

    /**
     * NOTE: vera_get_ifc_name is currently unsupported.
     * @param signal The Signal to check.
     * @return The name of the interface containing signal.
     */
    public static String vera_get_ifc_name(Signal signal)
    {
        // DEFERRED: vera_get_ifc_name
        throw new UnsupportedOperationException("vera_get_ifc_name()");
    }

    /**
     * Return the name of the clock associated with the given signal.
     * @param signal The signal to check.
     * @return The name of the clock signal associated with signal.
     */
    public static String vera_get_clk_name(Signal signal)
    {
        return signal.getClock().getName();
    }

    /**
     * Returns the direction of the given signal. The table below describes the
     * return value:
     * <P>
     * <table><center>
     * <tr><td><b>Return Value</b></td><td><b>Direction</b></td></tr>
     * <tr><td>0</td><td>Input Signal</td></tr>
     * <tr><td>1</td><td>Output Signal</td></tr>
     * <tr><td>2</td><td>InOut Signal</td></tr>
     * </center></table>
     *
     * @param signal The signal to check.
     * @return 0, 1, or 2 depending on the direction of the signal.
     */
    public static int vera_get_dir(Signal signal)
    {
        boolean isInOut = false;
        boolean isOut = false;

        if (signal instanceof PortSignalWrapper)
        {
            PortSignalWrapper wrapper = (PortSignalWrapper) signal;
            if (wrapper.isInput() && wrapper.isOutput())
            {
                isInOut = true;
            }
            else if (wrapper.isOutput())
            {
                isOut = true;
            }
        }
        else
        {
            if (signal instanceof InOutSignal)
            {
                isInOut = true;
            }
            else if (signal instanceof OutputSignal)
            {
                isOut = true;
            }
        }

        if (isInOut)
        {
            // inout
            return 2;
        }
        else if (isOut)
        {
            // output
            return 1;
        }
        else
        {
            // input
            return 0;
        }
    }

    /**
     * Returns the width of the given signal.
     * @param signal The signal to check.
     * @return The width of the given signal.
     */
    public static int vera_get_width(Signal signal)
    {
        return signal.getSize();
    }

    /**
     * Returns the type of input signal is represented by the given signal.
     * The table below describes the
     * return value:
     * <P>
     * <table><center>
     * <tr><td><b>Return Value</b></td><td><b>Signal Type</b></td></tr>
     * <tr><td>0</td><td>NSAMPLE</td></tr>
     * <tr><td>1</td><td>PSAMPLE</td></tr>
     * <tr><td>2</td><td>CLOCK</td></tr>
     * <tr><td>3</td><td>DDR</td></tr>
     * </center></table>
     *
     * @param signal The signal to check.
     * @return 0, 1, 2, or 3, depending on the type of the signal.
     */
    public static int vera_get_in_type(Signal signal)
    {
        boolean isClock = false;
        if (signal instanceof PortSignalWrapper)
        {
            isClock = ((PortSignalWrapper) signal).isClock();
        }
        else if (signal instanceof ClockSignal)
        {
            isClock = true;
            ;
        }

        if (isClock)
        {
            // CLOCK
            return 2;
        }
        else
        {
            InputSignal inputSignal = (InputSignal) signal;
            EdgeSet inputEdges = inputSignal.getInputEdges();
            if (EdgeSet.POSEDGE.contains(inputEdges))
            {
                // PSAMPLE
                return 1;
            }
            else if (EdgeSet.NEGEDGE.contains(inputEdges))
            {
                // NSAMPLE
                return 0;
            }
            else
            {
                // DDR
                return 3;
            }
        }
    }

    /**
     * Returns the input skew of the given signal.
     * @param signal The signal to check.
     * @return The input skew ofthe given signal.
     */
    public static int vera_get_in_skew(Signal signal)
    {
        InputSignal inputSignal = (InputSignal) signal;
        return inputSignal.getInputSkew();
    }

    /**
     * Returns the input depth of the given signal.
     * @param signal The signal to check.
     * @return The input depth ofthe given signal.
     */
    public static int vera_get_in_depth(Signal signal)
    {
        InputSignal inputSignal = (InputSignal) signal;
        return inputSignal.getInputDepth() - 1;
    }

    /**
     * Returns the type of output signal is represented by the given signal.
     * The table below describes the
     * return value:
     * <P>
     * <table><center>
     * <tr><td><b>Return Value</b></td><td><b>Signal Type</b></td></tr>
     * <tr><td>0</td><td>NHOLD</td></tr>
     * <tr><td>1</td><td>PHOLD</td></tr>
     * <tr><td>10</td><td>DDR</td></tr>
     * </center></table>
     *
     * @param signal The signal to check.
     * @return 0, 1, or 10, depending on the type of the signal.
     */
    public static int vera_get_out_type(Signal signal)
    {
        OutputSignal outputSignal = (OutputSignal) signal;
        EdgeSet inputEdges = outputSignal.getOutputEdges();
        if (EdgeSet.POSEDGE.contains(inputEdges))
        {
            // PHOLD
            return 1;
        }
        else if (EdgeSet.NEGEDGE.contains(inputEdges))
        {
            // NHOLD
            return 0;
        }
        else
        {
            // DDR
            return 10;
        }
    }

    /**
     * Returns the output skew of the given signal.
     * @param signal The signal to check.
     * @return The output skew ofthe given signal.
     */
    public static int vera_get_out_skew(Signal signal)
    {
        OutputSignal outputSignal = (OutputSignal) signal;
        return outputSignal.getOutputSkew();
    }

    ////////////////////////////////////////////////////////////
    // Miscellaneous
    ////////////////////////////////////////////////////////////

    /**
     * NOTE: vera_report_profile is currently unsupported
     * @param type
     * @param filename
     */
    public static void vera_report_profile(int type, String filename)
    {
        throw new UnsupportedOperationException("vera_report_profile()");
    }
}
